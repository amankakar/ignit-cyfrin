/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IAccessControlUpgradeable.sol";
   7 |     | import "../utils/ContextUpgradeable.sol";
   8 |     | import "../utils/StringsUpgradeable.sol";
   9 |     | import "../utils/introspection/ERC165Upgradeable.sol";
  10 |     | import "../proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Contract module that allows children to implement role-based access
  14 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  15 |     |  * members except through off-chain means by accessing the contract event logs. Some
  16 |     |  * applications may benefit from on-chain enumerability, for those cases see
  17 |     |  * {AccessControlEnumerable}.
  18 |     |  *
  19 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  20 |     |  * in the external API and be unique. The best way to achieve this is by
  21 |     |  * using `public constant` hash digests:
  22 |     |  *
  23 |     |  * ```
  24 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  25 |     |  * ```
  26 |     |  *
  27 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  28 |     |  * function call, use {hasRole}:
  29 |     |  *
  30 |     |  * ```
  31 |     |  * function foo() public {
  32 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  33 |     |  *     ...
  34 |     |  * }
  35 |     |  * ```
  36 |     |  *
  37 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  38 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  39 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  40 |     |  *
  41 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  42 |     |  * that only accounts with this role will be able to grant or revoke other
  43 |     |  * roles. More complex role relationships can be created by using
  44 |     |  * {_setRoleAdmin}.
  45 |     |  *
  46 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  47 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  48 |     |  * accounts that have been granted it.
  49 |     |  */
  50 |     | abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {
  51 |     |     function __AccessControl_init() internal onlyInitializing {
  52 |     |     }
  53 |     | 
  54 |     |     function __AccessControl_init_unchained() internal onlyInitializing {
  55 |     |     }
  56 |     |     struct RoleData {
  57 |     |         mapping(address => bool) members;
  58 |     |         bytes32 adminRole;
  59 |     |     }
  60 |     | 
  61 |     |     mapping(bytes32 => RoleData) private _roles;
  62 |     | 
  63 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  67 |     |      * with a standardized message including the required role.
  68 |     |      *
  69 |     |      * The format of the revert reason is given by the following regular expression:
  70 |     |      *
  71 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
  72 |     |      *
  73 |     |      * _Available since v4.1._
  74 |     |      */
  75 |     |     modifier onlyRole(bytes32 role) {
  76 | *   |         _checkRole(role);
  77 |     |         _;
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev See {IERC165-supportsInterface}.
  82 |     |      */
  83 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  84 |     |         return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Returns `true` if `account` has been granted `role`.
  89 |     |      */
  90 |     |     function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
  91 | *   |         return _roles[role].members[account];
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Revert with a standard message if `_msgSender()` is missing `role`.
  96 |     |      * Overriding this function changes the behavior of the {onlyRole} modifier.
  97 |     |      *
  98 |     |      * Format of the revert message is described in {_checkRole}.
  99 |     |      *
 100 |     |      * _Available since v4.6._
 101 |     |      */
 102 | *   |     function _checkRole(bytes32 role) internal view virtual {
 103 |     |         _checkRole(role, _msgSender());
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Revert with a standard message if `account` is missing `role`.
 108 |     |      *
 109 |     |      * The format of the revert reason is given by the following regular expression:
 110 |     |      *
 111 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
 112 |     |      */
 113 |     |     function _checkRole(bytes32 role, address account) internal view virtual {
 114 | *   |         if (!hasRole(role, account)) {
 115 |     |             revert(
 116 |     |                 string(
 117 |     |                     abi.encodePacked(
 118 |     |                         "AccessControl: account ",
 119 |     |                         StringsUpgradeable.toHexString(account),
 120 |     |                         " is missing role ",
 121 |     |                         StringsUpgradeable.toHexString(uint256(role), 32)
 122 |     |                     )
 123 |     |                 )
 124 |     |             );
 125 |     |         }
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 130 |     |      * {revokeRole}.
 131 |     |      *
 132 |     |      * To change a role's admin, use {_setRoleAdmin}.
 133 |     |      */
 134 | *   |     function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
 135 | *   |         return _roles[role].adminRole;
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev Grants `role` to `account`.
 140 |     |      *
 141 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 142 |     |      * event.
 143 |     |      *
 144 |     |      * Requirements:
 145 |     |      *
 146 |     |      * - the caller must have ``role``'s admin role.
 147 |     |      *
 148 |     |      * May emit a {RoleGranted} event.
 149 |     |      */
 150 | *   |     function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 151 |     |         _grantRole(role, account);
 152 |     |     }
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Revokes `role` from `account`.
 156 |     |      *
 157 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 158 |     |      *
 159 |     |      * Requirements:
 160 |     |      *
 161 |     |      * - the caller must have ``role``'s admin role.
 162 |     |      *
 163 |     |      * May emit a {RoleRevoked} event.
 164 |     |      */
 165 | *   |     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 166 |     |         _revokeRole(role, account);
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Revokes `role` from the calling account.
 171 |     |      *
 172 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 173 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 174 |     |      * if they are compromised (such as when a trusted device is misplaced).
 175 |     |      *
 176 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 177 |     |      * event.
 178 |     |      *
 179 |     |      * Requirements:
 180 |     |      *
 181 |     |      * - the caller must be `account`.
 182 |     |      *
 183 |     |      * May emit a {RoleRevoked} event.
 184 |     |      */
 185 |     |     function renounceRole(bytes32 role, address account) public virtual override {
 186 |     |         require(account == _msgSender(), "AccessControl: can only renounce roles for self");
 187 |     | 
 188 |     |         _revokeRole(role, account);
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @dev Grants `role` to `account`.
 193 |     |      *
 194 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 195 |     |      * event. Note that unlike {grantRole}, this function doesn't perform any
 196 |     |      * checks on the calling account.
 197 |     |      *
 198 |     |      * May emit a {RoleGranted} event.
 199 |     |      *
 200 |     |      * [WARNING]
 201 |     |      * ====
 202 |     |      * This function should only be called from the constructor when setting
 203 |     |      * up the initial roles for the system.
 204 |     |      *
 205 |     |      * Using this function in any other way is effectively circumventing the admin
 206 |     |      * system imposed by {AccessControl}.
 207 |     |      * ====
 208 |     |      *
 209 |     |      * NOTE: This function is deprecated in favor of {_grantRole}.
 210 |     |      */
 211 |     |     function _setupRole(bytes32 role, address account) internal virtual {
 212 |     |         _grantRole(role, account);
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 217 |     |      *
 218 |     |      * Emits a {RoleAdminChanged} event.
 219 |     |      */
 220 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 221 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 222 |     |         _roles[role].adminRole = adminRole;
 223 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 224 |     |     }
 225 |     | 
 226 |     |     /**
 227 |     |      * @dev Grants `role` to `account`.
 228 |     |      *
 229 |     |      * Internal function without access restriction.
 230 |     |      *
 231 |     |      * May emit a {RoleGranted} event.
 232 |     |      */
 233 |     |     function _grantRole(bytes32 role, address account) internal virtual {
 234 | *   |         if (!hasRole(role, account)) {
 235 |     |             _roles[role].members[account] = true;
 236 | *   |             emit RoleGranted(role, account, _msgSender());
 237 |     |         }
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @dev Revokes `role` from `account`.
 242 |     |      *
 243 |     |      * Internal function without access restriction.
 244 |     |      *
 245 |     |      * May emit a {RoleRevoked} event.
 246 |     |      */
 247 |     |     function _revokeRole(bytes32 role, address account) internal virtual {
 248 |     |         if (hasRole(role, account)) {
 249 |     |             _roles[role].members[account] = false;
 250 |     |             emit RoleRevoked(role, account, _msgSender());
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 256 |     |      * variables without shifting down storage in the inheritance chain.
 257 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 258 |     |      */
 259 |     |     uint256[49] private __gap;
 260 |     | }
 261 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
  8 |     |  */
  9 |     | interface IAccessControlUpgradeable {
 10 |     |     /**
 11 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
 12 |     |      *
 13 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
 14 |     |      * {RoleAdminChanged} not being emitted signaling this.
 15 |     |      *
 16 |     |      * _Available since v3.1._
 17 |     |      */
 18 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev Emitted when `account` is granted `role`.
 22 |     |      *
 23 |     |      * `sender` is the account that originated the contract call, an admin role
 24 |     |      * bearer except when using {AccessControl-_setupRole}.
 25 |     |      */
 26 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Emitted when `account` is revoked `role`.
 30 |     |      *
 31 |     |      * `sender` is the account that originated the contract call:
 32 |     |      *   - if using `revokeRole`, it is the admin role bearer
 33 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
 34 |     |      */
 35 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Returns `true` if `account` has been granted `role`.
 39 |     |      */
 40 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 44 |     |      * {revokeRole}.
 45 |     |      *
 46 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
 47 |     |      */
 48 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
 49 |     | 
 50 |     |     /**
 51 |     |      * @dev Grants `role` to `account`.
 52 |     |      *
 53 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 54 |     |      * event.
 55 |     |      *
 56 |     |      * Requirements:
 57 |     |      *
 58 |     |      * - the caller must have ``role``'s admin role.
 59 |     |      */
 60 |     |     function grantRole(bytes32 role, address account) external;
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Revokes `role` from `account`.
 64 |     |      *
 65 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 66 |     |      *
 67 |     |      * Requirements:
 68 |     |      *
 69 |     |      * - the caller must have ``role``'s admin role.
 70 |     |      */
 71 |     |     function revokeRole(bytes32 role, address account) external;
 72 |     | 
 73 |     |     /**
 74 |     |      * @dev Revokes `role` from the calling account.
 75 |     |      *
 76 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 77 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 78 |     |      * if they are compromised (such as when a trusted device is misplaced).
 79 |     |      *
 80 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
 81 |     |      * event.
 82 |     |      *
 83 |     |      * Requirements:
 84 |     |      *
 85 |     |      * - the caller must be `account`.
 86 |     |      */
 87 |     |     function renounceRole(bytes32 role, address account) external;
 88 |     | }
 89 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.2;
   5 |     | 
   6 |     | import "../../utils/AddressUpgradeable.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
  10 |     |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
  11 |     |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
  12 |     |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
  13 |     |  *
  14 |     |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
  15 |     |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
  16 |     |  * case an upgrade adds a module that needs to be initialized.
  17 |     |  *
  18 |     |  * For example:
  19 |     |  *
  20 |     |  * [.hljs-theme-light.nopadding]
  21 |     |  * ```
  22 |     |  * contract MyToken is ERC20Upgradeable {
  23 |     |  *     function initialize() initializer public {
  24 |     |  *         __ERC20_init("MyToken", "MTK");
  25 |     |  *     }
  26 |     |  * }
  27 |     |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
  28 |     |  *     function initializeV2() reinitializer(2) public {
  29 |     |  *         __ERC20Permit_init("MyToken");
  30 |     |  *     }
  31 |     |  * }
  32 |     |  * ```
  33 |     |  *
  34 |     |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
  35 |     |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
  36 |     |  *
  37 |     |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
  38 |     |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
  39 |     |  *
  40 |     |  * [CAUTION]
  41 |     |  * ====
  42 |     |  * Avoid leaving a contract uninitialized.
  43 |     |  *
  44 |     |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
  45 |     |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
  46 |     |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
  47 |     |  *
  48 |     |  * [.hljs-theme-light.nopadding]
  49 |     |  * ```
  50 |     |  * /// @custom:oz-upgrades-unsafe-allow constructor
  51 |     |  * constructor() {
  52 |     |  *     _disableInitializers();
  53 |     |  * }
  54 |     |  * ```
  55 |     |  * ====
  56 |     |  */
  57 |     | abstract contract Initializable {
  58 |     |     /**
  59 |     |      * @dev Indicates that the contract has been initialized.
  60 |     |      * @custom:oz-retyped-from bool
  61 |     |      */
  62 |     |     uint8 private _initialized;
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev Indicates that the contract is in the process of being initialized.
  66 |     |      */
  67 |     |     bool private _initializing;
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Triggered when the contract has been initialized or reinitialized.
  71 |     |      */
  72 |     |     event Initialized(uint8 version);
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
  76 |     |      * `onlyInitializing` functions can be used to initialize parent contracts.
  77 |     |      *
  78 |     |      * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a
  79 |     |      * constructor.
  80 |     |      *
  81 |     |      * Emits an {Initialized} event.
  82 |     |      */
  83 |     |     modifier initializer() {
  84 | *   |         bool isTopLevelCall = !_initializing;
  85 |     |         require(
  86 | *   |             (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
  87 |     |             "Initializable: contract is already initialized"
  88 |     |         );
  89 |     |         _initialized = 1;
  90 | *   |         if (isTopLevelCall) {
  91 |     |             _initializing = true;
  92 |     |         }
  93 |     |         _;
  94 | *   |         if (isTopLevelCall) {
  95 |     |             _initializing = false;
  96 | *   |             emit Initialized(1);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
 102 |     |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
 103 |     |      * used to initialize parent contracts.
 104 |     |      *
 105 |     |      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
 106 |     |      * are added through upgrades and that require initialization.
 107 |     |      *
 108 |     |      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
 109 |     |      * cannot be nested. If one is invoked in the context of another, execution will revert.
 110 |     |      *
 111 |     |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
 112 |     |      * a contract, executing them in the right order is up to the developer or operator.
 113 |     |      *
 114 |     |      * WARNING: setting the version to 255 will prevent any future reinitialization.
 115 |     |      *
 116 |     |      * Emits an {Initialized} event.
 117 |     |      */
 118 |     |     modifier reinitializer(uint8 version) {
 119 |     |         require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
 120 |     |         _initialized = version;
 121 |     |         _initializing = true;
 122 |     |         _;
 123 |     |         _initializing = false;
 124 |     |         emit Initialized(version);
 125 |     |     }
 126 |     | 
 127 |     |     /**
 128 |     |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
 129 |     |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
 130 |     |      */
 131 |     |     modifier onlyInitializing() {
 132 | *   |         require(_initializing, "Initializable: contract is not initializing");
 133 |     |         _;
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
 138 |     |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
 139 |     |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
 140 |     |      * through proxies.
 141 |     |      *
 142 |     |      * Emits an {Initialized} event the first time it is successfully executed.
 143 |     |      */
 144 |     |     function _disableInitializers() internal virtual {
 145 |     |         require(!_initializing, "Initializable: contract is initializing");
 146 |     |         if (_initialized < type(uint8).max) {
 147 |     |             _initialized = type(uint8).max;
 148 |     |             emit Initialized(type(uint8).max);
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     /**
 153 |     |      * @dev Returns the highest version that has been initialized. See {reinitializer}.
 154 |     |      */
 155 |     |     function _getInitializedVersion() internal view returns (uint8) {
 156 |     |         return _initialized;
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
 161 |     |      */
 162 |     |     function _isInitializing() internal view returns (bool) {
 163 |     |         return _initializing;
 164 |     |     }
 165 |     | }
 166 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../utils/ContextUpgradeable.sol";
   7 |     | import "../proxy/utils/Initializable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Contract module which allows children to implement an emergency stop
  11 |     |  * mechanism that can be triggered by an authorized account.
  12 |     |  *
  13 |     |  * This module is used through inheritance. It will make available the
  14 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  15 |     |  * the functions of your contract. Note that they will not be pausable by
  16 |     |  * simply including this module, only once the modifiers are put in place.
  17 |     |  */
  18 |     | abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {
  19 |     |     /**
  20 |     |      * @dev Emitted when the pause is triggered by `account`.
  21 |     |      */
  22 |     |     event Paused(address account);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Emitted when the pause is lifted by `account`.
  26 |     |      */
  27 |     |     event Unpaused(address account);
  28 |     | 
  29 |     |     bool private _paused;
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Initializes the contract in unpaused state.
  33 |     |      */
  34 |     |     function __Pausable_init() internal onlyInitializing {
  35 |     |         __Pausable_init_unchained();
  36 |     |     }
  37 |     | 
  38 |     |     function __Pausable_init_unchained() internal onlyInitializing {
  39 | *   |         _paused = false;
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  44 |     |      *
  45 |     |      * Requirements:
  46 |     |      *
  47 |     |      * - The contract must not be paused.
  48 |     |      */
  49 | *   |     modifier whenNotPaused() {
  50 |     |         _requireNotPaused();
  51 |     |         _;
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      *
  59 |     |      * - The contract must be paused.
  60 |     |      */
  61 |     |     modifier whenPaused() {
  62 |     |         _requirePaused();
  63 |     |         _;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  68 |     |      */
  69 |     |     function paused() public view virtual returns (bool) {
  70 | *   |         return _paused;
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Throws if the contract is paused.
  75 |     |      */
  76 | *   |     function _requireNotPaused() internal view virtual {
  77 |     |         require(!paused(), "Pausable: paused");
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Throws if the contract is not paused.
  82 |     |      */
  83 |     |     function _requirePaused() internal view virtual {
  84 |     |         require(paused(), "Pausable: not paused");
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Triggers stopped state.
  89 |     |      *
  90 |     |      * Requirements:
  91 |     |      *
  92 |     |      * - The contract must not be paused.
  93 |     |      */
  94 |     |     function _pause() internal virtual whenNotPaused {
  95 |     |         _paused = true;
  96 |     |         emit Paused(_msgSender());
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns to normal state.
 101 |     |      *
 102 |     |      * Requirements:
 103 |     |      *
 104 |     |      * - The contract must be paused.
 105 |     |      */
 106 |     |     function _unpause() internal virtual whenPaused {
 107 |     |         _paused = false;
 108 |     |         emit Unpaused(_msgSender());
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 113 |     |      * variables without shifting down storage in the inheritance chain.
 114 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 115 |     |      */
 116 |     |     uint256[49] private __gap;
 117 |     | }
 118 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | import "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  9 |     |  *
 10 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 11 |     |  * available, which can be applied to functions to make sure there are no nested
 12 |     |  * (reentrant) calls to them.
 13 |     |  *
 14 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 15 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 16 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 17 |     |  * points to them.
 18 |     |  *
 19 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 20 |     |  * to protect against it, check out our blog post
 21 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 22 |     |  */
 23 |     | abstract contract ReentrancyGuardUpgradeable is Initializable {
 24 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 25 |     |     // word because each write operation emits an extra SLOAD to first read the
 26 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 27 |     |     // back. This is the compiler's defense against contract upgrades and
 28 |     |     // pointer aliasing, and it cannot be disabled.
 29 |     | 
 30 |     |     // The values being non-zero value makes deployment a bit more expensive,
 31 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 32 |     |     // amount. Since refunds are capped to a percentage of the total
 33 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 34 |     |     // increase the likelihood of the full refund coming into effect.
 35 | *   |     uint256 private constant _NOT_ENTERED = 1;
 36 | *   |     uint256 private constant _ENTERED = 2;
 37 |     | 
 38 |     |     uint256 private _status;
 39 |     | 
 40 |     |     function __ReentrancyGuard_init() internal onlyInitializing {
 41 |     |         __ReentrancyGuard_init_unchained();
 42 |     |     }
 43 |     | 
 44 |     |     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
 45 |     |         _status = _NOT_ENTERED;
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 50 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 51 |     |      * function is not supported. It is possible to prevent this from happening
 52 |     |      * by making the `nonReentrant` function external, and making it call a
 53 |     |      * `private` function that does the actual work.
 54 |     |      */
 55 | *   |     modifier nonReentrant() {
 56 |     |         _nonReentrantBefore();
 57 | *   |         _;
 58 |     |         _nonReentrantAfter();
 59 |     |     }
 60 |     | 
 61 | *   |     function _nonReentrantBefore() private {
 62 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 63 | *   |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 64 |     | 
 65 |     |         // Any calls to nonReentrant after this point will fail
 66 |     |         _status = _ENTERED;
 67 |     |     }
 68 |     | 
 69 |     |     function _nonReentrantAfter() private {
 70 |     |         // By storing the original value once again, a refund is triggered (see
 71 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 72 | *   |         _status = _NOT_ENTERED;
 73 |     |     }
 74 |     | 
 75 |     |     /**
 76 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 77 |     |      * variables without shifting down storage in the inheritance chain.
 78 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 79 |     |      */
 80 |     |     uint256[49] private __gap;
 81 |     | }
 82 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20Upgradeable {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20Upgradeable.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20MetadataUpgradeable is IERC20Upgradeable {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  */
 14 |     | interface IERC20PermitUpgradeable {
 15 |     |     /**
 16 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 17 |     |      * given ``owner``'s signed approval.
 18 |     |      *
 19 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 20 |     |      * ordering also apply here.
 21 |     |      *
 22 |     |      * Emits an {Approval} event.
 23 |     |      *
 24 |     |      * Requirements:
 25 |     |      *
 26 |     |      * - `spender` cannot be the zero address.
 27 |     |      * - `deadline` must be a timestamp in the future.
 28 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 29 |     |      * over the EIP712-formatted function arguments.
 30 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 31 |     |      *
 32 |     |      * For more information on the signature format, see the
 33 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 34 |     |      * section].
 35 |     |      */
 36 |     |     function permit(
 37 |     |         address owner,
 38 |     |         address spender,
 39 |     |         uint256 value,
 40 |     |         uint256 deadline,
 41 |     |         uint8 v,
 42 |     |         bytes32 r,
 43 |     |         bytes32 s
 44 |     |     ) external;
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Returns the current nonce for `owner`. This value must be
 48 |     |      * included whenever a signature is generated for {permit}.
 49 |     |      *
 50 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 51 |     |      * prevents a signature from being used multiple times.
 52 |     |      */
 53 |     |     function nonces(address owner) external view returns (uint256);
 54 |     | 
 55 |     |     /**
 56 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 57 |     |      */
 58 |     |     // solhint-disable-next-line func-name-mixedcase
 59 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 60 |     | }
 61 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20Upgradeable.sol";
   7 |     | import "../extensions/draft-IERC20PermitUpgradeable.sol";
   8 |     | import "../../../utils/AddressUpgradeable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20Upgradeable {
  20 |     |     using AddressUpgradeable for address;
  21 |     | 
  22 | *   |     function safeTransfer(
  23 |     |         IERC20Upgradeable token,
  24 |     |         address to,
  25 |     |         uint256 value
  26 |     |     ) internal {
  27 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 | *   |     function safeTransferFrom(
  31 |     |         IERC20Upgradeable token,
  32 |     |         address from,
  33 |     |         address to,
  34 |     |         uint256 value
  35 |     |     ) internal {
  36 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  41 |     |      * {IERC20-approve}, and its usage is discouraged.
  42 |     |      *
  43 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  44 |     |      * {safeDecreaseAllowance} instead.
  45 |     |      */
  46 |     |     function safeApprove(
  47 |     |         IERC20Upgradeable token,
  48 |     |         address spender,
  49 |     |         uint256 value
  50 |     |     ) internal {
  51 |     |         // safeApprove should only be called when setting an initial allowance,
  52 |     |         // or when resetting it to zero. To increase and decrease it, use
  53 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  54 |     |         require(
  55 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  56 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  57 |     |         );
  58 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  59 |     |     }
  60 |     | 
  61 |     |     function safeIncreaseAllowance(
  62 |     |         IERC20Upgradeable token,
  63 |     |         address spender,
  64 |     |         uint256 value
  65 |     |     ) internal {
  66 |     |         uint256 newAllowance = token.allowance(address(this), spender) + value;
  67 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  68 |     |     }
  69 |     | 
  70 |     |     function safeDecreaseAllowance(
  71 |     |         IERC20Upgradeable token,
  72 |     |         address spender,
  73 |     |         uint256 value
  74 |     |     ) internal {
  75 |     |         unchecked {
  76 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  77 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  78 |     |             uint256 newAllowance = oldAllowance - value;
  79 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 |     |     function safePermit(
  84 |     |         IERC20PermitUpgradeable token,
  85 |     |         address owner,
  86 |     |         address spender,
  87 |     |         uint256 value,
  88 |     |         uint256 deadline,
  89 |     |         uint8 v,
  90 |     |         bytes32 r,
  91 |     |         bytes32 s
  92 |     |     ) internal {
  93 |     |         uint256 nonceBefore = token.nonces(owner);
  94 |     |         token.permit(owner, spender, value, deadline, v, r, s);
  95 |     |         uint256 nonceAfter = token.nonces(owner);
  96 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 101 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 102 |     |      * @param token The token targeted by the call.
 103 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 104 |     |      */
 105 | *   |     function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
 106 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 107 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 108 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 109 |     | 
 110 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 111 | *   |         if (returndata.length > 0) {
 112 |     |             // Return data is optional
 113 | *   |             require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 114 |     |         }
 115 |     |     }
 116 |     | }
 117 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library AddressUpgradeable {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      * ====
  26 |     |      *
  27 |     |      * [IMPORTANT]
  28 |     |      * ====
  29 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  30 |     |      *
  31 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  32 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  33 |     |      * constructor.
  34 |     |      * ====
  35 |     |      */
  36 |     |     function isContract(address account) internal view returns (bool) {
  37 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  38 |     |         // for contracts in construction, since the code is only stored at the end
  39 |     |         // of the constructor execution.
  40 |     | 
  41 |     |         return account.code.length > 0;
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  46 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  47 |     |      *
  48 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  49 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  50 |     |      * imposed by `transfer`, making them unable to receive funds via
  51 |     |      * `transfer`. {sendValue} removes this limitation.
  52 |     |      *
  53 |     |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  54 |     |      *
  55 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  56 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  57 |     |      * {ReentrancyGuard} or the
  58 |     |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  59 |     |      */
  60 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  61 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  62 |     | 
  63 |     |         (bool success, ) = recipient.call{value: amount}("");
  64 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  69 |     |      * plain `call` is an unsafe replacement for a function call: use this
  70 |     |      * function instead.
  71 |     |      *
  72 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  73 |     |      * function (like regular Solidity function calls).
  74 |     |      *
  75 |     |      * Returns the raw returned data. To convert to the expected return value,
  76 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - `target` must be a contract.
  81 |     |      * - calling `target` with `data` must not revert.
  82 |     |      *
  83 |     |      * _Available since v3.1._
  84 |     |      */
  85 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  86 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  91 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  92 |     |      *
  93 |     |      * _Available since v3.1._
  94 |     |      */
  95 |     |     function functionCall(
  96 |     |         address target,
  97 |     |         bytes memory data,
  98 |     |         string memory errorMessage
  99 |     |     ) internal returns (bytes memory) {
 100 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 105 |     |      * but also transferring `value` wei to `target`.
 106 |     |      *
 107 |     |      * Requirements:
 108 |     |      *
 109 |     |      * - the calling contract must have an ETH balance of at least `value`.
 110 |     |      * - the called Solidity function must be `payable`.
 111 |     |      *
 112 |     |      * _Available since v3.1._
 113 |     |      */
 114 |     |     function functionCallWithValue(
 115 |     |         address target,
 116 |     |         bytes memory data,
 117 |     |         uint256 value
 118 |     |     ) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 | *   |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 166 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 167 |     |      *
 168 |     |      * _Available since v4.8._
 169 |     |      */
 170 | *   |     function verifyCallResultFromTarget(
 171 |     |         address target,
 172 |     |         bool success,
 173 |     |         bytes memory returndata,
 174 |     |         string memory errorMessage
 175 |     |     ) internal view returns (bytes memory) {
 176 | *   |         if (success) {
 177 | *   |             if (returndata.length == 0) {
 178 |     |                 // only check isContract if the call was successful and the return data is empty
 179 |     |                 // otherwise we already know that it was a contract
 180 |     |                 require(isContract(target), "Address: call to non-contract");
 181 |     |             }
 182 | *   |             return returndata;
 183 |     |         } else {
 184 |     |             _revert(returndata, errorMessage);
 185 |     |         }
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 190 |     |      * revert reason or using the provided one.
 191 |     |      *
 192 |     |      * _Available since v4.3._
 193 |     |      */
 194 |     |     function verifyCallResult(
 195 |     |         bool success,
 196 |     |         bytes memory returndata,
 197 |     |         string memory errorMessage
 198 |     |     ) internal pure returns (bytes memory) {
 199 |     |         if (success) {
 200 |     |             return returndata;
 201 |     |         } else {
 202 |     |             _revert(returndata, errorMessage);
 203 |     |         }
 204 |     |     }
 205 |     | 
 206 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 207 |     |         // Look for revert reason and bubble it up if present
 208 |     |         if (returndata.length > 0) {
 209 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 210 |     |             /// @solidity memory-safe-assembly
 211 |     |             assembly {
 212 |     |                 let returndata_size := mload(returndata)
 213 |     |                 revert(add(32, returndata), returndata_size)
 214 |     |             }
 215 |     |         } else {
 216 |     |             revert(errorMessage);
 217 |     |         }
 218 |     |     }
 219 |     | }
 220 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | import "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Provides information about the current execution context, including the
  9 |     |  * sender of the transaction and its data. While these are generally available
 10 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 11 |     |  * manner, since when dealing with meta-transactions the account sending and
 12 |     |  * paying for execution may not be the actual sender (as far as an application
 13 |     |  * is concerned).
 14 |     |  *
 15 |     |  * This contract is only required for intermediate, library-like contracts.
 16 |     |  */
 17 |     | abstract contract ContextUpgradeable is Initializable {
 18 |     |     function __Context_init() internal onlyInitializing {
 19 |     |     }
 20 |     | 
 21 |     |     function __Context_init_unchained() internal onlyInitializing {
 22 |     |     }
 23 |     |     function _msgSender() internal view virtual returns (address) {
 24 | *   |         return msg.sender;
 25 |     |     }
 26 |     | 
 27 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 28 |     |         return msg.data;
 29 |     |     }
 30 |     | 
 31 |     |     /**
 32 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 33 |     |      * variables without shifting down storage in the inheritance chain.
 34 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 35 |     |      */
 36 |     |     uint256[50] private __gap;
 37 |     | }
 38 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/MathUpgradeable.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev String operations.
 10 |     |  */
 11 |     | library StringsUpgradeable {
 12 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 13 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 14 |     | 
 15 |     |     /**
 16 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 17 |     |      */
 18 |     |     function toString(uint256 value) internal pure returns (string memory) {
 19 |     |         unchecked {
 20 |     |             uint256 length = MathUpgradeable.log10(value) + 1;
 21 |     |             string memory buffer = new string(length);
 22 |     |             uint256 ptr;
 23 |     |             /// @solidity memory-safe-assembly
 24 |     |             assembly {
 25 |     |                 ptr := add(buffer, add(32, length))
 26 |     |             }
 27 |     |             while (true) {
 28 |     |                 ptr--;
 29 |     |                 /// @solidity memory-safe-assembly
 30 |     |                 assembly {
 31 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 32 |     |                 }
 33 |     |                 value /= 10;
 34 |     |                 if (value == 0) break;
 35 |     |             }
 36 |     |             return buffer;
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 42 |     |      */
 43 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 44 |     |         unchecked {
 45 |     |             return toHexString(value, MathUpgradeable.log256(value) + 1);
 46 |     |         }
 47 |     |     }
 48 |     | 
 49 |     |     /**
 50 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 51 |     |      */
 52 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 53 |     |         bytes memory buffer = new bytes(2 * length + 2);
 54 |     |         buffer[0] = "0";
 55 |     |         buffer[1] = "x";
 56 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 57 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 58 |     |             value >>= 4;
 59 |     |         }
 60 |     |         require(value == 0, "Strings: hex length insufficient");
 61 |     |         return string(buffer);
 62 |     |     }
 63 |     | 
 64 |     |     /**
 65 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 66 |     |      */
 67 |     |     function toHexString(address addr) internal pure returns (string memory) {
 68 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 69 |     |     }
 70 |     | }
 71 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165Upgradeable.sol";
  7 |     | import "../../proxy/utils/Initializable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Implementation of the {IERC165} interface.
 11 |     |  *
 12 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 13 |     |  * for the additional interface id that will be supported. For example:
 14 |     |  *
 15 |     |  * ```solidity
 16 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 17 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 18 |     |  * }
 19 |     |  * ```
 20 |     |  *
 21 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 22 |     |  */
 23 |     | abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
 24 |     |     function __ERC165_init() internal onlyInitializing {
 25 |     |     }
 26 |     | 
 27 |     |     function __ERC165_init_unchained() internal onlyInitializing {
 28 |     |     }
 29 |     |     /**
 30 |     |      * @dev See {IERC165-supportsInterface}.
 31 |     |      */
 32 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 33 |     |         return interfaceId == type(IERC165Upgradeable).interfaceId;
 34 |     |     }
 35 |     | 
 36 |     |     /**
 37 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 38 |     |      * variables without shifting down storage in the inheritance chain.
 39 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 40 |     |      */
 41 |     |     uint256[50] private __gap;
 42 |     | }
 43 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165Upgradeable {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library MathUpgradeable {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(
  56 |     |         uint256 x,
  57 |     |         uint256 y,
  58 |     |         uint256 denominator
  59 |     |     ) internal pure returns (uint256 result) {
  60 |     |         unchecked {
  61 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  62 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  63 |     |             // variables such that product = prod1 * 2^256 + prod0.
  64 |     |             uint256 prod0; // Least significant 256 bits of the product
  65 |     |             uint256 prod1; // Most significant 256 bits of the product
  66 |     |             assembly {
  67 |     |                 let mm := mulmod(x, y, not(0))
  68 |     |                 prod0 := mul(x, y)
  69 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  70 |     |             }
  71 |     | 
  72 |     |             // Handle non-overflow cases, 256 by 256 division.
  73 |     |             if (prod1 == 0) {
  74 |     |                 return prod0 / denominator;
  75 |     |             }
  76 |     | 
  77 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  78 |     |             require(denominator > prod1);
  79 |     | 
  80 |     |             ///////////////////////////////////////////////
  81 |     |             // 512 by 256 division.
  82 |     |             ///////////////////////////////////////////////
  83 |     | 
  84 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  85 |     |             uint256 remainder;
  86 |     |             assembly {
  87 |     |                 // Compute remainder using mulmod.
  88 |     |                 remainder := mulmod(x, y, denominator)
  89 |     | 
  90 |     |                 // Subtract 256 bit number from 512 bit number.
  91 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  92 |     |                 prod0 := sub(prod0, remainder)
  93 |     |             }
  94 |     | 
  95 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  96 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  97 |     | 
  98 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  99 |     |             uint256 twos = denominator & (~denominator + 1);
 100 |     |             assembly {
 101 |     |                 // Divide denominator by twos.
 102 |     |                 denominator := div(denominator, twos)
 103 |     | 
 104 |     |                 // Divide [prod1 prod0] by twos.
 105 |     |                 prod0 := div(prod0, twos)
 106 |     | 
 107 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 108 |     |                 twos := add(div(sub(0, twos), twos), 1)
 109 |     |             }
 110 |     | 
 111 |     |             // Shift in bits from prod1 into prod0.
 112 |     |             prod0 |= prod1 * twos;
 113 |     | 
 114 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 115 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 116 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 117 |     |             uint256 inverse = (3 * denominator) ^ 2;
 118 |     | 
 119 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 120 |     |             // in modular arithmetic, doubling the correct bits in each step.
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 126 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 127 |     | 
 128 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 129 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 130 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 131 |     |             // is no longer required.
 132 |     |             result = prod0 * inverse;
 133 |     |             return result;
 134 |     |         }
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 139 |     |      */
 140 |     |     function mulDiv(
 141 |     |         uint256 x,
 142 |     |         uint256 y,
 143 |     |         uint256 denominator,
 144 |     |         Rounding rounding
 145 |     |     ) internal pure returns (uint256) {
 146 |     |         uint256 result = mulDiv(x, y, denominator);
 147 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 148 |     |             result += 1;
 149 |     |         }
 150 |     |         return result;
 151 |     |     }
 152 |     | 
 153 |     |     /**
 154 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 155 |     |      *
 156 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 157 |     |      */
 158 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 159 |     |         if (a == 0) {
 160 |     |             return 0;
 161 |     |         }
 162 |     | 
 163 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 164 |     |         //
 165 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 166 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 167 |     |         //
 168 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 169 |     |         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 170 |     |         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 171 |     |         //
 172 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 173 |     |         uint256 result = 1 << (log2(a) >> 1);
 174 |     | 
 175 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 176 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 177 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 178 |     |         // into the expected uint128 result.
 179 |     |         unchecked {
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             result = (result + a / result) >> 1;
 182 |     |             result = (result + a / result) >> 1;
 183 |     |             result = (result + a / result) >> 1;
 184 |     |             result = (result + a / result) >> 1;
 185 |     |             result = (result + a / result) >> 1;
 186 |     |             result = (result + a / result) >> 1;
 187 |     |             return min(result, a / result);
 188 |     |         }
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 193 |     |      */
 194 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 195 |     |         unchecked {
 196 |     |             uint256 result = sqrt(a);
 197 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 203 |     |      * Returns 0 if given 0.
 204 |     |      */
 205 |     |     function log2(uint256 value) internal pure returns (uint256) {
 206 |     |         uint256 result = 0;
 207 |     |         unchecked {
 208 |     |             if (value >> 128 > 0) {
 209 |     |                 value >>= 128;
 210 |     |                 result += 128;
 211 |     |             }
 212 |     |             if (value >> 64 > 0) {
 213 |     |                 value >>= 64;
 214 |     |                 result += 64;
 215 |     |             }
 216 |     |             if (value >> 32 > 0) {
 217 |     |                 value >>= 32;
 218 |     |                 result += 32;
 219 |     |             }
 220 |     |             if (value >> 16 > 0) {
 221 |     |                 value >>= 16;
 222 |     |                 result += 16;
 223 |     |             }
 224 |     |             if (value >> 8 > 0) {
 225 |     |                 value >>= 8;
 226 |     |                 result += 8;
 227 |     |             }
 228 |     |             if (value >> 4 > 0) {
 229 |     |                 value >>= 4;
 230 |     |                 result += 4;
 231 |     |             }
 232 |     |             if (value >> 2 > 0) {
 233 |     |                 value >>= 2;
 234 |     |                 result += 2;
 235 |     |             }
 236 |     |             if (value >> 1 > 0) {
 237 |     |                 result += 1;
 238 |     |             }
 239 |     |         }
 240 |     |         return result;
 241 |     |     }
 242 |     | 
 243 |     |     /**
 244 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 245 |     |      * Returns 0 if given 0.
 246 |     |      */
 247 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 248 |     |         unchecked {
 249 |     |             uint256 result = log2(value);
 250 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 256 |     |      * Returns 0 if given 0.
 257 |     |      */
 258 |     |     function log10(uint256 value) internal pure returns (uint256) {
 259 |     |         uint256 result = 0;
 260 |     |         unchecked {
 261 |     |             if (value >= 10**64) {
 262 |     |                 value /= 10**64;
 263 |     |                 result += 64;
 264 |     |             }
 265 |     |             if (value >= 10**32) {
 266 |     |                 value /= 10**32;
 267 |     |                 result += 32;
 268 |     |             }
 269 |     |             if (value >= 10**16) {
 270 |     |                 value /= 10**16;
 271 |     |                 result += 16;
 272 |     |             }
 273 |     |             if (value >= 10**8) {
 274 |     |                 value /= 10**8;
 275 |     |                 result += 8;
 276 |     |             }
 277 |     |             if (value >= 10**4) {
 278 |     |                 value /= 10**4;
 279 |     |                 result += 4;
 280 |     |             }
 281 |     |             if (value >= 10**2) {
 282 |     |                 value /= 10**2;
 283 |     |                 result += 2;
 284 |     |             }
 285 |     |             if (value >= 10**1) {
 286 |     |                 result += 1;
 287 |     |             }
 288 |     |         }
 289 |     |         return result;
 290 |     |     }
 291 |     | 
 292 |     |     /**
 293 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 294 |     |      * Returns 0 if given 0.
 295 |     |      */
 296 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 297 |     |         unchecked {
 298 |     |             uint256 result = log10(value);
 299 |     |             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
 300 |     |         }
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 305 |     |      * Returns 0 if given 0.
 306 |     |      *
 307 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 308 |     |      */
 309 |     |     function log256(uint256 value) internal pure returns (uint256) {
 310 |     |         uint256 result = 0;
 311 |     |         unchecked {
 312 |     |             if (value >> 128 > 0) {
 313 |     |                 value >>= 128;
 314 |     |                 result += 16;
 315 |     |             }
 316 |     |             if (value >> 64 > 0) {
 317 |     |                 value >>= 64;
 318 |     |                 result += 8;
 319 |     |             }
 320 |     |             if (value >> 32 > 0) {
 321 |     |                 value >>= 32;
 322 |     |                 result += 4;
 323 |     |             }
 324 |     |             if (value >> 16 > 0) {
 325 |     |                 value >>= 16;
 326 |     |                 result += 2;
 327 |     |             }
 328 |     |             if (value >> 8 > 0) {
 329 |     |                 result += 1;
 330 |     |             }
 331 |     |         }
 332 |     |         return result;
 333 |     |     }
 334 |     | 
 335 |     |     /**
 336 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 337 |     |      * Returns 0 if given 0.
 338 |     |      */
 339 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 340 |     |         unchecked {
 341 |     |             uint256 result = log256(value);
 342 |     |             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
 343 |     |         }
 344 |     |     }
 345 |     | }
 346 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.0;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for managing
   9 |     |  * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
  10 |     |  * types.
  11 |     |  *
  12 |     |  * Sets have the following properties:
  13 |     |  *
  14 |     |  * - Elements are added, removed, and checked for existence in constant time
  15 |     |  * (O(1)).
  16 |     |  * - Elements are enumerated in O(n). No guarantees are made on the ordering.
  17 |     |  *
  18 |     |  * ```
  19 |     |  * contract Example {
  20 |     |  *     // Add the library methods
  21 |     |  *     using EnumerableSet for EnumerableSet.AddressSet;
  22 |     |  *
  23 |     |  *     // Declare a set state variable
  24 |     |  *     EnumerableSet.AddressSet private mySet;
  25 |     |  * }
  26 |     |  * ```
  27 |     |  *
  28 |     |  * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
  29 |     |  * and `uint256` (`UintSet`) are supported.
  30 |     |  *
  31 |     |  * [WARNING]
  32 |     |  * ====
  33 |     |  * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
  34 |     |  * unusable.
  35 |     |  * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
  36 |     |  *
  37 |     |  * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an
  38 |     |  * array of EnumerableSet.
  39 |     |  * ====
  40 |     |  */
  41 |     | library EnumerableSetUpgradeable {
  42 |     |     // To implement this library for multiple types with as little code
  43 |     |     // repetition as possible, we write it in terms of a generic Set type with
  44 |     |     // bytes32 values.
  45 |     |     // The Set implementation uses private functions, and user-facing
  46 |     |     // implementations (such as AddressSet) are just wrappers around the
  47 |     |     // underlying Set.
  48 |     |     // This means that we can only create new EnumerableSets for types that fit
  49 |     |     // in bytes32.
  50 |     | 
  51 |     |     struct Set {
  52 |     |         // Storage of set values
  53 |     |         bytes32[] _values;
  54 |     |         // Position of the value in the `values` array, plus 1 because index 0
  55 |     |         // means a value is not in the set.
  56 |     |         mapping(bytes32 => uint256) _indexes;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Add a value to a set. O(1).
  61 |     |      *
  62 |     |      * Returns true if the value was added to the set, that is if it was not
  63 |     |      * already present.
  64 |     |      */
  65 | *   |     function _add(Set storage set, bytes32 value) private returns (bool) {
  66 | *   |         if (!_contains(set, value)) {
  67 |     |             set._values.push(value);
  68 |     |             // The value is stored at length-1, but we add 1 to all indexes
  69 |     |             // and use 0 as a sentinel value
  70 |     |             set._indexes[value] = set._values.length;
  71 | *   |             return true;
  72 |     |         } else {
  73 |     |             return false;
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Removes a value from a set. O(1).
  79 |     |      *
  80 |     |      * Returns true if the value was removed from the set, that is if it was
  81 |     |      * present.
  82 |     |      */
  83 |     |     function _remove(Set storage set, bytes32 value) private returns (bool) {
  84 |     |         // We read and store the value's index to prevent multiple reads from the same storage slot
  85 |     |         uint256 valueIndex = set._indexes[value];
  86 |     | 
  87 |     |         if (valueIndex != 0) {
  88 |     |             // Equivalent to contains(set, value)
  89 |     |             // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
  90 |     |             // the array, and then remove the last element (sometimes called as 'swap and pop').
  91 |     |             // This modifies the order of the array, as noted in {at}.
  92 |     | 
  93 |     |             uint256 toDeleteIndex = valueIndex - 1;
  94 |     |             uint256 lastIndex = set._values.length - 1;
  95 |     | 
  96 |     |             if (lastIndex != toDeleteIndex) {
  97 |     |                 bytes32 lastValue = set._values[lastIndex];
  98 |     | 
  99 |     |                 // Move the last value to the index where the value to delete is
 100 |     |                 set._values[toDeleteIndex] = lastValue;
 101 |     |                 // Update the index for the moved value
 102 |     |                 set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
 103 |     |             }
 104 |     | 
 105 |     |             // Delete the slot where the moved value was stored
 106 |     |             set._values.pop();
 107 |     | 
 108 |     |             // Delete the index for the deleted slot
 109 |     |             delete set._indexes[value];
 110 |     | 
 111 |     |             return true;
 112 |     |         } else {
 113 |     |             return false;
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns true if the value is in the set. O(1).
 119 |     |      */
 120 | *   |     function _contains(Set storage set, bytes32 value) private view returns (bool) {
 121 | *   |         return set._indexes[value] != 0;
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev Returns the number of values on the set. O(1).
 126 |     |      */
 127 |     |     function _length(Set storage set) private view returns (uint256) {
 128 |     |         return set._values.length;
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 133 |     |      *
 134 |     |      * Note that there are no guarantees on the ordering of values inside the
 135 |     |      * array, and it may change when more values are added or removed.
 136 |     |      *
 137 |     |      * Requirements:
 138 |     |      *
 139 |     |      * - `index` must be strictly less than {length}.
 140 |     |      */
 141 |     |     function _at(Set storage set, uint256 index) private view returns (bytes32) {
 142 |     |         return set._values[index];
 143 |     |     }
 144 |     | 
 145 |     |     /**
 146 |     |      * @dev Return the entire set in an array
 147 |     |      *
 148 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 149 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 150 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 151 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 152 |     |      */
 153 |     |     function _values(Set storage set) private view returns (bytes32[] memory) {
 154 |     |         return set._values;
 155 |     |     }
 156 |     | 
 157 |     |     // Bytes32Set
 158 |     | 
 159 |     |     struct Bytes32Set {
 160 |     |         Set _inner;
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Add a value to a set. O(1).
 165 |     |      *
 166 |     |      * Returns true if the value was added to the set, that is if it was not
 167 |     |      * already present.
 168 |     |      */
 169 |     |     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
 170 |     |         return _add(set._inner, value);
 171 |     |     }
 172 |     | 
 173 |     |     /**
 174 |     |      * @dev Removes a value from a set. O(1).
 175 |     |      *
 176 |     |      * Returns true if the value was removed from the set, that is if it was
 177 |     |      * present.
 178 |     |      */
 179 |     |     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
 180 |     |         return _remove(set._inner, value);
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Returns true if the value is in the set. O(1).
 185 |     |      */
 186 |     |     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
 187 |     |         return _contains(set._inner, value);
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @dev Returns the number of values in the set. O(1).
 192 |     |      */
 193 |     |     function length(Bytes32Set storage set) internal view returns (uint256) {
 194 |     |         return _length(set._inner);
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 199 |     |      *
 200 |     |      * Note that there are no guarantees on the ordering of values inside the
 201 |     |      * array, and it may change when more values are added or removed.
 202 |     |      *
 203 |     |      * Requirements:
 204 |     |      *
 205 |     |      * - `index` must be strictly less than {length}.
 206 |     |      */
 207 |     |     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
 208 |     |         return _at(set._inner, index);
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @dev Return the entire set in an array
 213 |     |      *
 214 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 215 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 216 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 217 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 218 |     |      */
 219 |     |     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
 220 |     |         bytes32[] memory store = _values(set._inner);
 221 |     |         bytes32[] memory result;
 222 |     | 
 223 |     |         /// @solidity memory-safe-assembly
 224 |     |         assembly {
 225 |     |             result := store
 226 |     |         }
 227 |     | 
 228 |     |         return result;
 229 |     |     }
 230 |     | 
 231 |     |     // AddressSet
 232 |     | 
 233 |     |     struct AddressSet {
 234 |     |         Set _inner;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Add a value to a set. O(1).
 239 |     |      *
 240 |     |      * Returns true if the value was added to the set, that is if it was not
 241 |     |      * already present.
 242 |     |      */
 243 |     |     function add(AddressSet storage set, address value) internal returns (bool) {
 244 | *   |         return _add(set._inner, bytes32(uint256(uint160(value))));
 245 |     |     }
 246 |     | 
 247 |     |     /**
 248 |     |      * @dev Removes a value from a set. O(1).
 249 |     |      *
 250 |     |      * Returns true if the value was removed from the set, that is if it was
 251 |     |      * present.
 252 |     |      */
 253 |     |     function remove(AddressSet storage set, address value) internal returns (bool) {
 254 |     |         return _remove(set._inner, bytes32(uint256(uint160(value))));
 255 |     |     }
 256 |     | 
 257 |     |     /**
 258 |     |      * @dev Returns true if the value is in the set. O(1).
 259 |     |      */
 260 |     |     function contains(AddressSet storage set, address value) internal view returns (bool) {
 261 | *   |         return _contains(set._inner, bytes32(uint256(uint160(value))));
 262 |     |     }
 263 |     | 
 264 |     |     /**
 265 |     |      * @dev Returns the number of values in the set. O(1).
 266 |     |      */
 267 |     |     function length(AddressSet storage set) internal view returns (uint256) {
 268 |     |         return _length(set._inner);
 269 |     |     }
 270 |     | 
 271 |     |     /**
 272 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 273 |     |      *
 274 |     |      * Note that there are no guarantees on the ordering of values inside the
 275 |     |      * array, and it may change when more values are added or removed.
 276 |     |      *
 277 |     |      * Requirements:
 278 |     |      *
 279 |     |      * - `index` must be strictly less than {length}.
 280 |     |      */
 281 |     |     function at(AddressSet storage set, uint256 index) internal view returns (address) {
 282 |     |         return address(uint160(uint256(_at(set._inner, index))));
 283 |     |     }
 284 |     | 
 285 |     |     /**
 286 |     |      * @dev Return the entire set in an array
 287 |     |      *
 288 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 289 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 290 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 291 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 292 |     |      */
 293 |     |     function values(AddressSet storage set) internal view returns (address[] memory) {
 294 |     |         bytes32[] memory store = _values(set._inner);
 295 |     |         address[] memory result;
 296 |     | 
 297 |     |         /// @solidity memory-safe-assembly
 298 |     |         assembly {
 299 |     |             result := store
 300 |     |         }
 301 |     | 
 302 |     |         return result;
 303 |     |     }
 304 |     | 
 305 |     |     // UintSet
 306 |     | 
 307 |     |     struct UintSet {
 308 |     |         Set _inner;
 309 |     |     }
 310 |     | 
 311 |     |     /**
 312 |     |      * @dev Add a value to a set. O(1).
 313 |     |      *
 314 |     |      * Returns true if the value was added to the set, that is if it was not
 315 |     |      * already present.
 316 |     |      */
 317 |     |     function add(UintSet storage set, uint256 value) internal returns (bool) {
 318 |     |         return _add(set._inner, bytes32(value));
 319 |     |     }
 320 |     | 
 321 |     |     /**
 322 |     |      * @dev Removes a value from a set. O(1).
 323 |     |      *
 324 |     |      * Returns true if the value was removed from the set, that is if it was
 325 |     |      * present.
 326 |     |      */
 327 |     |     function remove(UintSet storage set, uint256 value) internal returns (bool) {
 328 |     |         return _remove(set._inner, bytes32(value));
 329 |     |     }
 330 |     | 
 331 |     |     /**
 332 |     |      * @dev Returns true if the value is in the set. O(1).
 333 |     |      */
 334 |     |     function contains(UintSet storage set, uint256 value) internal view returns (bool) {
 335 |     |         return _contains(set._inner, bytes32(value));
 336 |     |     }
 337 |     | 
 338 |     |     /**
 339 |     |      * @dev Returns the number of values in the set. O(1).
 340 |     |      */
 341 |     |     function length(UintSet storage set) internal view returns (uint256) {
 342 |     |         return _length(set._inner);
 343 |     |     }
 344 |     | 
 345 |     |     /**
 346 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 347 |     |      *
 348 |     |      * Note that there are no guarantees on the ordering of values inside the
 349 |     |      * array, and it may change when more values are added or removed.
 350 |     |      *
 351 |     |      * Requirements:
 352 |     |      *
 353 |     |      * - `index` must be strictly less than {length}.
 354 |     |      */
 355 |     |     function at(UintSet storage set, uint256 index) internal view returns (uint256) {
 356 |     |         return uint256(_at(set._inner, index));
 357 |     |     }
 358 |     | 
 359 |     |     /**
 360 |     |      * @dev Return the entire set in an array
 361 |     |      *
 362 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 363 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 364 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 365 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 366 |     |      */
 367 |     |     function values(UintSet storage set) internal view returns (uint256[] memory) {
 368 |     |         bytes32[] memory store = _values(set._inner);
 369 |     |         uint256[] memory result;
 370 |     | 
 371 |     |         /// @solidity memory-safe-assembly
 372 |     |         assembly {
 373 |     |             result := store
 374 |     |         }
 375 |     | 
 376 |     |         return result;
 377 |     |     }
 378 |     | }
 379 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 | *   |         _name = name_;
  56 | *   |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 |     |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 |     |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 |     |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 |     |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 |     |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 |     |     ) public virtual override returns (bool) {
 163 |     |         address spender = _msgSender();
 164 |     |         _spendAllowance(from, spender, amount);
 165 | *   |         _transfer(from, to, amount);
 166 |     |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 | *   |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 |     |     ) internal virtual {
 231 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 232 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 |     |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 |     |         uint256 fromBalance = _balances[from];
 237 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 |     |             _balances[from] = fromBalance - amount;
 240 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 241 |     |             // decrementing then incrementing.
 242 |     |             _balances[to] += amount;
 243 |     |         }
 244 |     | 
 245 | *   |         emit Transfer(from, to, amount);
 246 |     | 
 247 |     |         _afterTokenTransfer(from, to, amount);
 248 |     |     }
 249 |     | 
 250 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 251 |     |      * the total supply.
 252 |     |      *
 253 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 254 |     |      *
 255 |     |      * Requirements:
 256 |     |      *
 257 |     |      * - `account` cannot be the zero address.
 258 |     |      */
 259 |     |     function _mint(address account, uint256 amount) internal virtual {
 260 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 261 |     | 
 262 |     |         _beforeTokenTransfer(address(0), account, amount);
 263 |     | 
 264 | *   |         _totalSupply += amount;
 265 |     |         unchecked {
 266 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 267 |     |             _balances[account] += amount;
 268 |     |         }
 269 | *   |         emit Transfer(address(0), account, amount);
 270 |     | 
 271 |     |         _afterTokenTransfer(address(0), account, amount);
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 276 |     |      * total supply.
 277 |     |      *
 278 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 279 |     |      *
 280 |     |      * Requirements:
 281 |     |      *
 282 |     |      * - `account` cannot be the zero address.
 283 |     |      * - `account` must have at least `amount` tokens.
 284 |     |      */
 285 |     |     function _burn(address account, uint256 amount) internal virtual {
 286 |     |         require(account != address(0), "ERC20: burn from the zero address");
 287 |     | 
 288 |     |         _beforeTokenTransfer(account, address(0), amount);
 289 |     | 
 290 |     |         uint256 accountBalance = _balances[account];
 291 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 292 |     |         unchecked {
 293 |     |             _balances[account] = accountBalance - amount;
 294 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 295 |     |             _totalSupply -= amount;
 296 |     |         }
 297 |     | 
 298 |     |         emit Transfer(account, address(0), amount);
 299 |     | 
 300 |     |         _afterTokenTransfer(account, address(0), amount);
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 305 |     |      *
 306 |     |      * This internal function is equivalent to `approve`, and can be used to
 307 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 308 |     |      *
 309 |     |      * Emits an {Approval} event.
 310 |     |      *
 311 |     |      * Requirements:
 312 |     |      *
 313 |     |      * - `owner` cannot be the zero address.
 314 |     |      * - `spender` cannot be the zero address.
 315 |     |      */
 316 | *   |     function _approve(
 317 |     |         address owner,
 318 |     |         address spender,
 319 |     |         uint256 amount
 320 |     |     ) internal virtual {
 321 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 322 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 323 |     | 
 324 | *   |         _allowances[owner][spender] = amount;
 325 | *   |         emit Approval(owner, spender, amount);
 326 |     |     }
 327 |     | 
 328 |     |     /**
 329 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 330 |     |      *
 331 |     |      * Does not update the allowance amount in case of infinite allowance.
 332 |     |      * Revert if not enough allowance is available.
 333 |     |      *
 334 |     |      * Might emit an {Approval} event.
 335 |     |      */
 336 |     |     function _spendAllowance(
 337 |     |         address owner,
 338 |     |         address spender,
 339 |     |         uint256 amount
 340 |     |     ) internal virtual {
 341 |     |         uint256 currentAllowance = allowance(owner, spender);
 342 | *   |         if (currentAllowance != type(uint256).max) {
 343 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 344 |     |             unchecked {
 345 |     |                 _approve(owner, spender, currentAllowance - amount);
 346 |     |             }
 347 |     |         }
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * will be transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _beforeTokenTransfer(
 365 |     |         address from,
 366 |     |         address to,
 367 |     |         uint256 amount
 368 |     |     ) internal virtual {}
 369 |     | 
 370 |     |     /**
 371 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 372 |     |      * minting and burning.
 373 |     |      *
 374 |     |      * Calling conditions:
 375 |     |      *
 376 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 377 |     |      * has been transferred to `to`.
 378 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 379 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 380 |     |      * - `from` and `to` are never both zero.
 381 |     |      *
 382 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 383 |     |      */
 384 |     |     function _afterTokenTransfer(
 385 |     |         address from,
 386 |     |         address to,
 387 |     |         uint256 amount
 388 |     |     ) internal virtual {}
 389 |     | }
 390 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/chimera/src/Asserts.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract Asserts {
  5 |     |     function gt(uint256 a, uint256 b, string memory reason) internal virtual;
  6 |     | 
  7 |     |     function gte(uint256 a, uint256 b, string memory reason) internal virtual;
  8 |     | 
  9 |     |     function lt(uint256 a, uint256 b, string memory reason) internal virtual;
 10 |     | 
 11 |     |     function lte(uint256 a, uint256 b, string memory reason) internal virtual;
 12 |     | 
 13 |     |     function eq(uint256 a, uint256 b, string memory reason) internal virtual;
 14 |     | 
 15 |     |     function t(bool b, string memory reason) internal virtual;
 16 |     | 
 17 |     |     function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);
 18 |     | 
 19 |     |     function between(int256 value, int256 low, int256 high) internal virtual returns (int256);
 20 |     | 
 21 |     |     function precondition(bool p) internal virtual;
 22 |     | }
 23 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/chimera/src/BaseProperties.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | import {BaseSetup} from "./BaseSetup.sol";
 5 |     | 
 6 |     | abstract contract BaseProperties is BaseSetup {}
 7 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/chimera/src/BaseSetup.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | abstract contract BaseSetup {
 5 |     |     function setup() internal virtual;
 6 |     | }
 7 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/chimera/src/BaseTargetFunctions.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | import {BaseProperties} from "./BaseProperties.sol";
 5 |     | import {Asserts} from "./Asserts.sol";
 6 |     | 
 7 |     | abstract contract BaseTargetFunctions is BaseProperties, Asserts {}
 8 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/chimera/src/CryticAsserts.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Asserts} from "./Asserts.sol";
  5 |     | 
  6 |     | contract CryticAsserts is Asserts {
  7 |     |     event Log(string);
  8 |     | 
  9 |     |     function gt(uint256 a, uint256 b, string memory reason) internal virtual override {
 10 |     |         if (!(a > b)) {
 11 |     |             emit Log(reason);
 12 |     |             assert(false);
 13 |     |         }
 14 |     |     }
 15 |     | 
 16 |     |     function gte(uint256 a, uint256 b, string memory reason) internal virtual override {
 17 |     |         if (!(a >= b)) {
 18 |     |             emit Log(reason);
 19 |     |             assert(false);
 20 |     |         }
 21 |     |     }
 22 |     | 
 23 |     |     function lt(uint256 a, uint256 b, string memory reason) internal virtual override {
 24 |     |         if (!(a < b)) {
 25 |     |             emit Log(reason);
 26 |     |             assert(false);
 27 |     |         }
 28 |     |     }
 29 |     | 
 30 |     |     function lte(uint256 a, uint256 b, string memory reason) internal virtual override {
 31 |     |         if (!(a <= b)) {
 32 |     |             emit Log(reason);
 33 |     |             assert(false);
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function eq(uint256 a, uint256 b, string memory reason) internal virtual override {
 38 |     |         if (!(a == b)) {
 39 |     |             emit Log(reason);
 40 |     |             assert(false);
 41 |     |         }
 42 |     |     }
 43 |     | 
 44 |     |     function t(bool b, string memory reason) internal virtual override {
 45 |     |         if (!b) {
 46 |     |             emit Log(reason);
 47 |     |             assert(false);
 48 |     |         }
 49 |     |     }
 50 |     | 
 51 |     |     function between(uint256 value, uint256 low, uint256 high) internal virtual override returns (uint256) {
 52 |     |         if (value < low || value > high) {
 53 |     |             uint256 ans = low + (value % (high - low + 1));
 54 |     |             return ans;
 55 |     |         }
 56 |     |         return value;
 57 |     |     }
 58 |     | 
 59 |     |     function between(int256 value, int256 low, int256 high) internal virtual override returns (int256) {
 60 |     |         if (value < low || value > high) {
 61 |     |             int256 range = high - low + 1;
 62 |     |             int256 clamped = (value - low) % (range);
 63 |     |             if (clamped < 0) clamped += range;
 64 |     |             int256 ans = low + clamped;
 65 |     |             return ans;
 66 |     |         }
 67 |     |         return value;
 68 |     |     }
 69 |     | 
 70 |     |     function precondition(bool p) internal virtual override {
 71 |     |         require(p);
 72 |     |     }
 73 |     | }
 74 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/node_modules/chimera/src/Hevm.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | // slither-disable-start shadowing-local
  5 |     | 
  6 |     | interface IHevm {
  7 |     |     // Set block.timestamp to newTimestamp
  8 |     |     function warp(uint256 newTimestamp) external;
  9 |     | 
 10 |     |     // Set block.number to newNumber
 11 |     |     function roll(uint256 newNumber) external;
 12 |     | 
 13 |     |     // Add the condition b to the assumption base for the current branch
 14 |     |     // This function is almost identical to require
 15 |     |     function assume(bool b) external;
 16 |     | 
 17 |     |     // Sets the eth balance of usr to amt
 18 |     |     function deal(address usr, uint256 amt) external;
 19 |     | 
 20 |     |     // Loads a storage slot from an address
 21 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 22 |     | 
 23 |     |     // Stores a value to an address' storage slot
 24 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 25 |     | 
 26 |     |     // Signs data (privateKey, digest) => (v, r, s)
 27 |     |     function sign(uint256 privateKey, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
 28 |     | 
 29 |     |     // Gets address for a given private key
 30 |     |     function addr(uint256 privateKey) external returns (address addr);
 31 |     | 
 32 |     |     // Performs a foreign function call via terminal
 33 |     |     function ffi(string[] calldata inputs) external returns (bytes memory result);
 34 |     | 
 35 |     |     // Performs the next smart contract call with specified `msg.sender`
 36 |     |     function prank(address newSender) external;
 37 |     | 
 38 |     |     // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork
 39 |     |     function createFork(string calldata urlOrAlias) external returns (uint256);
 40 |     | 
 41 |     |     // Takes a fork identifier created by createFork and sets the corresponding forked state as active
 42 |     |     function selectFork(uint256 forkId) external;
 43 |     | 
 44 |     |     // Returns the identifier of the current fork
 45 |     |     function activeFork() external returns (uint256);
 46 |     | 
 47 |     |     // Labels the address in traces
 48 |     |     function label(address addr, string calldata label) external;
 49 |     | 
 50 |     |     /// Sets an address' code.
 51 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 52 |     | }
 53 |     | 
 54 | *r  | IHevm constant vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 55 |     | 
 56 |     | // slither-disable-end shadowing-local
 57 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/src/IPriceFeed.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IPriceFeed {
  5 |     |     function latestRoundData() external view returns (
  6 |     |         uint80 roundId,
  7 |     |         int256 answer,
  8 |     |         uint256 startedAt,
  9 |     |         uint256 updatedAt,
 10 |     |         uint80 answeredInRound
 11 |     |     );
 12 |     | }
 13 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/src/IStakedAvax.sol
 1 |     | // SPDX-License-Identifier: UNLICENSED
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | 
 5 |     | interface IStakedAvax {
 6 |     |     function accrueRewards(uint amount) external;
 7 |     | }
 8 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/src/Ignite.sol
    1 |     | // SPDX-License-Identifier: UNLICENSED
    2 |     | pragma solidity ^0.8.0;
    3 |     | 
    4 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
    5 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";
    6 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
    7 |     | import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
    8 |     | import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
    9 |     | import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
   10 |     | import "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol";
   11 |     | 
   12 |     | import "./IgniteStorage.sol";
   13 |     | import "./IPriceFeed.sol";
   14 |     | import "./IStakedAvax.sol";
   15 |     | import "./ValidatorRewarder.sol";
   16 |     | 
   17 |     | 
   18 | *   | contract Ignite is
   19 |     |     AccessControlUpgradeable,
   20 |     |     ReentrancyGuardUpgradeable,
   21 |     |     PausableUpgradeable,
   22 |     |     IgniteStorage
   23 |     | {
   24 |     |     using SafeERC20Upgradeable for IERC20Upgradeable;
   25 |     |     using SafeERC20Upgradeable for IERC20MetadataUpgradeable;
   26 |     |     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
   27 |     | 
   28 | *   |     bytes32 public constant ROLE_WITHDRAW = keccak256("ROLE_WITHDRAW");
   29 | *   |     bytes32 public constant ROLE_REGISTER_WITHOUT_COLLATERAL = keccak256("ROLE_REGISTER_WITHOUT_COLLATERAL");
   30 |     |     bytes32 public constant ROLE_RELEASE_LOCKED_TOKENS = keccak256("ROLE_RELEASE_LOCKED_TOKENS");
   31 |     |     bytes32 public constant ROLE_PAUSE = keccak256("ROLE_PAUSE");
   32 |     |     bytes32 public constant ROLE_UNPAUSE = keccak256("ROLE_UNPAUSE");
   33 |     |     bytes32 public constant ROLE_REGISTER_WITH_FLEXIBLE_PRICE_CHECK = keccak256("ROLE_REGISTER_WITH_FLEXIBLE_PRICE_CHECK");
   34 |     | 
   35 | *   |     uint public constant VALIDATION_DURATION_TWO_WEEKS = 86400 * 7 * 2;
   36 | *   |     uint public constant VALIDATION_DURATION_FOUR_WEEKS = 86400 * 7 * 4;
   37 | *   |     uint public constant VALIDATION_DURATION_EIGHT_WEEKS = 86400 * 7 * 8;
   38 | *   |     uint public constant VALIDATION_DURATION_TWELVE_WEEKS = 86400 * 7 * 12;
   39 | *   |     uint public constant VALIDATION_DURATION_ONE_YEAR = 86400 * 365;
   40 |     | 
   41 |     |     address public constant AVAX = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
   42 |     | 
   43 | *   |     address public constant FEE_RECIPIENT = 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa;
   44 | *   |     address public constant SLASHED_TOKEN_RECIPIENT = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;
   45 |     | 
   46 |     |     /// @dev Emitted when a user request validation to be started for a node
   47 |     |     event NewRegistration(
   48 |     |         address registerer,
   49 |     |         string nodeId,
   50 |     |         bytes blsProofOfPossession,
   51 |     |         uint validationDuration,
   52 |     |         bool feePaid,
   53 |     |         uint avaxAmount,
   54 |     |         address token,
   55 |     |         uint tokenAmount
   56 |     |     );
   57 |     | 
   58 |     |     /// @dev Emitted when a registration is removed from the array of registrations
   59 |     |     event RegistrationDeleted(string nodeId);
   60 |     | 
   61 |     |     /// @dev Emitted when AVAX is withdrawn from the contract for validation
   62 |     |     event Withdraw(uint amount);
   63 |     | 
   64 |     |     /// @dev Emitted when a validator is slashed for misbehaving
   65 |     |     event ValidatorSlashed(string nodeId, uint qiAmount, uint avaxAmount);
   66 |     | 
   67 |     |     /// @dev Emitted when the validation period for a node expires and the tokens are redeemable
   68 |     |     event RegistrationExpired(string nodeId);
   69 |     | 
   70 |     |     /// @dev Emitted when a user redeems their tokens after validation expiry or failed validation start attempt
   71 |     |     event Redeem(string nodeId, uint avaxAmount, address token, uint tokenAmount);
   72 |     | 
   73 |     |     /// @dev Emitted when a validator is rewarded
   74 |     |     event ValidatorRewarded(string nodeId, uint amount);
   75 |     | 
   76 |     |     /// @dev Emitted when QI slash percentage is updated
   77 |     |     event QiSlashPercentageChanged(uint oldPercentage, uint newPercentage);
   78 |     | 
   79 |     |     /// @dev Emitted when AVAX slash percentage is updated
   80 |     |     event AvaxSlashPercentageChanged(uint oldPercentage, uint newPercentage);
   81 |     | 
   82 |     |     /// @dev Emitted when the maximum protocol AVAX subsidisation amount is updated
   83 |     |     event MaximumSubsidisationAmountChanged(
   84 |     |         uint oldMaximumSubsidisationAmount,
   85 |     |         uint newMaximumSubsidisationAmount
   86 |     |     );
   87 |     | 
   88 |     |     /// @dev Emitted when a new fee payment option is added
   89 |     |     event PaymentTokenAdded(address token);
   90 |     | 
   91 |     |     /// @dev Emitted when an existing fee payment option is removed
   92 |     |     event PaymentTokenRemoved(address token);
   93 |     | 
   94 |     |     /// @dev Emitted when a price feed address is updated
   95 |     |     event PriceFeedChanged(
   96 |     |         address token,
   97 |     |         address oldFeed,
   98 |     |         address newFeed,
   99 |     |         uint oldMaxPriceAge,
  100 |     |         uint newMaxPriceAge
  101 |     |     );
  102 |     | 
  103 |     |     /// @dev Emitted when the registration AVAX requirement is updated
  104 |     |     event AvaxDepositRangeUpdated(
  105 |     |         uint oldMinimumAvaxDeposit,
  106 |     |         uint newMinimumAvaxDeposit,
  107 |     |         uint oldMaximumAvaxDeposit,
  108 |     |         uint newMaximumAvaxDeposit
  109 |     |     );
  110 |     | 
  111 |     |     /// @dev Emitted when the QI price multiplier for fee payments is updated
  112 |     |     event QiPriceMultiplierUpdated(uint oldQiPriceMultiplier, uint newQiPriceMultiplier);
  113 |     | 
  114 |     | 
  115 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  116 |     |     constructor() {
  117 |     |         // _disableInitializers();
  118 |     |     }
  119 |     | 
  120 |     |     function initialize(
  121 |     |         address _sAVAX,
  122 |     |         address _qi,
  123 |     |         address _avaxPriceFeed,
  124 |     |         uint _maxAvaxPriceAge,
  125 |     |         address _qiPriceFeed,
  126 |     |         uint _maxQiPriceAge,
  127 |     |         uint _minimumAvaxDeposit,
  128 |     |         uint _maximumAvaxDeposit
  129 |     |     ) initializer public {
  130 | *   |         require(_minimumAvaxDeposit <= _maximumAvaxDeposit);
  131 |     | 
  132 |     |         __AccessControl_init();
  133 |     |         __ReentrancyGuard_init();
  134 |     |         __Pausable_init();
  135 |     | 
  136 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
  137 |     | 
  138 |     |         sAVAX = IStakedAvax(_sAVAX);
  139 |     |         qi = IERC20Upgradeable(_qi);
  140 |     | 
  141 |     |         _initialisePriceFeeds(_avaxPriceFeed, _maxAvaxPriceAge, _qi, _qiPriceFeed, _maxQiPriceAge);
  142 |     | 
  143 | *   |         minimumAvaxDeposit = _minimumAvaxDeposit;
  144 | *   |         maximumAvaxDeposit = _maximumAvaxDeposit;
  145 |     | 
  146 | *   |         qiSlashPercentage = 5_000;
  147 | *   |         maximumSubsidisationAmount = 50_000e18;
  148 |     | 
  149 | *   |         qiPriceMultiplier = 10_000;
  150 |     | 
  151 | *   |         registrations.push(
  152 | *   |             Registration(
  153 |     |                 address(0),
  154 |     |                 "",
  155 |     |                 0,
  156 |     |                 false,
  157 | *   |                 TokenDepositDetails(
  158 |     |                     0,
  159 |     |                     address(0),
  160 |     |                     0
  161 |     |                 ),
  162 |     |                 0,
  163 |     |                 0,
  164 |     |                 0,
  165 |     |                 false,
  166 |     |                 false
  167 |     |             )
  168 |     |         );
  169 |     |     }
  170 |     | 
  171 |     |     function _initialisePriceFeeds(
  172 |     |         address _avaxPriceFeed,
  173 |     |         uint _maxAvaxPriceAge,
  174 |     |         address _qi,
  175 |     |         address _qiPriceFeed,
  176 |     |         uint _maxQiPriceAge
  177 |     |     ) internal onlyInitializing {
  178 |     |         IPriceFeed avaxPriceFeed = IPriceFeed(_avaxPriceFeed);
  179 |     |         IPriceFeed qiPriceFeed = IPriceFeed(_qiPriceFeed);
  180 |     | 
  181 | *   |         priceFeeds[AVAX] = avaxPriceFeed;
  182 |     |         priceFeeds[_qi] = qiPriceFeed;
  183 |     | 
  184 | *   |         maxPriceAges[AVAX] = _maxAvaxPriceAge;
  185 |     |         maxPriceAges[_qi] = _maxQiPriceAge;
  186 |     | 
  187 | *   |         (, int256 avaxPrice, , uint avaxPriceUpdatedAt, ) = avaxPriceFeed.latestRoundData();
  188 | *   |         require(avaxPrice > 0);
  189 | *   |         require(block.timestamp - avaxPriceUpdatedAt <= _maxAvaxPriceAge);
  190 |     | 
  191 | *   |         (, int256 qiPrice, , uint qiPriceUpdatedAt, ) = qiPriceFeed.latestRoundData();
  192 | *   |         require(qiPrice > 0);
  193 | *   |         require(block.timestamp - qiPriceUpdatedAt <= _maxQiPriceAge);
  194 |     |     }
  195 |     | 
  196 |     |     /**
  197 |     |      * @notice Register a new node for validation and lock up QI and AVAX
  198 |     |      * @param  nodeId Node ID of the validator
  199 |     |      * @param  blsProofOfPossession BLS proof of possession (public key + signature)
  200 |     |      * @param  validationDuration Duration of the validation in seconds
  201 |     |      */
  202 |     |     function registerWithStake(
  203 |     |         string calldata nodeId,
  204 |     |         bytes calldata blsProofOfPossession,
  205 |     |         uint validationDuration
  206 |     |     ) external payable nonReentrant {
  207 |     |         require(
  208 | *   |             msg.value >= minimumAvaxDeposit &&
  209 | *   |             msg.value <= maximumAvaxDeposit &&
  210 | *   |             msg.value % 1e9 == 0,
  211 |     |             "Invalid value"
  212 |     |         );
  213 |     | 
  214 |     |         // Verify that the sender can receive AVAX
  215 | *   |         (bool success, ) = msg.sender.call("");
  216 |     |         require(success);
  217 |     | 
  218 | *   |         (, int256 avaxPrice, , uint avaxPriceUpdatedAt, ) = priceFeeds[AVAX].latestRoundData();
  219 | *   |         (, int256 qiPrice, , uint qiPriceUpdatedAt, ) = priceFeeds[address(qi)].latestRoundData();
  220 |     | 
  221 | *   |         require(qiPrice > 0 && avaxPrice > qiPrice); // @audit q what if the qi price surpass avax price ?
  222 | *   |         require(block.timestamp - avaxPriceUpdatedAt <= maxPriceAges[AVAX]);
  223 | *   |         require(block.timestamp - qiPriceUpdatedAt <= maxPriceAges[address(qi)]);
  224 |     | 
  225 |     |         // QI deposit amount is 10 % (thus, note the divider) of the AVAX value
  226 |     |         // that BENQI subsidises for the validator.
  227 | *   |         uint qiAmount = uint(avaxPrice) * (2000e18 - msg.value) / uint(qiPrice) / 10;
  228 |     | 
  229 | *   |         require(qiAmount > 0);
  230 |     | 
  231 | *   |         qi.safeTransferFrom(msg.sender, address(this), qiAmount);
  232 |     | 
  233 |     |         _registerWithChecks(
  234 |     |             msg.sender,
  235 |     |             nodeId,
  236 |     |             blsProofOfPossession,
  237 |     |             validationDuration,
  238 |     |             false,
  239 |     |             address(qi),
  240 |     |             qiAmount,
  241 |     |             false
  242 |     |         );
  243 |     |     }
  244 |     | 
  245 |     |     /**
  246 |     |      * @notice Register a node by paying a non-refundable fee in AVAX
  247 |     |      * @param  nodeId Node ID of the validator
  248 |     |      * @param  blsProofOfPossession BLS proof of possession (public key + signature)
  249 |     |      * @param  validationDuration Duration of the validation in seconds
  250 |     |      */
  251 |     |     function registerWithAvaxFee(
  252 |     |         string calldata nodeId,
  253 |     |         bytes calldata blsProofOfPossession,
  254 |     |         uint validationDuration
  255 |     |     ) external payable nonReentrant whenNotPaused {
  256 | *   |         uint registrationFee = _getRegistrationFee(validationDuration);
  257 | *   |         require(msg.value == registrationFee);
  258 |     | 
  259 |     |         // Verify that the sender can receive AVAX
  260 | *   |         (bool success, ) = msg.sender.call("");
  261 |     |         require(success);
  262 |     | 
  263 |     |         // Fees cannot be withdrawn from the contract until the registration is released
  264 | *   |         minimumContractBalance += registrationFee;
  265 |     | 
  266 |     |         _registerWithChecks(
  267 |     |             msg.sender,
  268 |     |             nodeId,
  269 |     |             blsProofOfPossession,
  270 |     |             validationDuration,
  271 | *   |             true,
  272 |     |             address(0),
  273 |     |             0,
  274 |     |             false
  275 |     |         );
  276 |     |     }
  277 |     | 
  278 |     |     /**
  279 |     |      * @notice Register a node by paying a non-refundable fee in a supported ERC-20 token
  280 |     |      * @param  tokenAddress ERC-20 payment token address
  281 |     |      * @param  nodeId Node ID of the validator
  282 |     |      * @param  blsProofOfPossession BLS proof of possession (public key + signature)
  283 |     |      * @param  validationDuration Duration of the validation in seconds
  284 |     |      */
  285 |     |     function registerWithErc20Fee(
  286 |     |         address tokenAddress,
  287 |     |         string calldata nodeId,
  288 |     |         bytes calldata blsProofOfPossession,
  289 |     |         uint validationDuration
  290 |     |     ) external nonReentrant whenNotPaused {
  291 |     |         require(paymentTokens.contains(tokenAddress));
  292 |     | 
  293 |     |         IERC20MetadataUpgradeable token = IERC20MetadataUpgradeable(tokenAddress);
  294 |     | 
  295 | *   |         (, int256 avaxPrice, , uint avaxPriceUpdatedAt, ) = priceFeeds[AVAX].latestRoundData();
  296 | *   |         (, int256 tokenPrice, , uint tokenPriceUpdatedAt, ) = priceFeeds[tokenAddress].latestRoundData();
  297 |     | 
  298 | *   |         require(avaxPrice > 0 && tokenPrice > 0);
  299 | *   |         require(block.timestamp - avaxPriceUpdatedAt <= maxPriceAges[AVAX]);
  300 | *   |         require(block.timestamp - tokenPriceUpdatedAt <= maxPriceAges[tokenAddress]);
  301 |     | 
  302 | *   |         uint registrationFee = _getRegistrationFee(validationDuration);
  303 | *   |         uint tokenAmount = uint(avaxPrice) * registrationFee / uint(tokenPrice) / 10 ** (18 - token.decimals());
  304 |     | 
  305 | *   |         if (tokenAddress == address(qi)) {
  306 | *   |             tokenAmount = tokenAmount * qiPriceMultiplier / 10_000;
  307 |     |         }
  308 |     | 
  309 | *   |         require(tokenAmount > 0);
  310 |     | 
  311 | *   |         token.safeTransferFrom(msg.sender, address(this), tokenAmount);
  312 |     | 
  313 |     |         _registerWithChecks(
  314 |     |             msg.sender,
  315 |     |             nodeId,
  316 |     |             blsProofOfPossession,
  317 |     |             validationDuration,
  318 |     |             true,
  319 |     |             tokenAddress,
  320 |     |             tokenAmount,
  321 |     |             false
  322 |     |         );
  323 |     |     }
  324 |     | 
  325 |     |     /**
  326 |     |      * @notice Register a new node for validation without locking up tokens
  327 |     |      * @param  nodeId Node ID of the validator
  328 |     |      * @param  blsProofOfPossession BLS proof of possession (public key + signature)
  329 |     |      * @param  validationDuration Duration of the validation in seconds
  330 |     |      */
  331 |     |     function registerWithoutCollateral(
  332 |     |         string calldata nodeId,
  333 |     |         bytes calldata blsProofOfPossession,
  334 |     |         uint validationDuration
  335 |     |     ) external {
  336 | *   |         require(hasRole(ROLE_REGISTER_WITHOUT_COLLATERAL, msg.sender));
  337 |     |         require(
  338 | *   |             validationDuration >= VALIDATION_DURATION_TWO_WEEKS &&
  339 | *   |             validationDuration <= VALIDATION_DURATION_ONE_YEAR,
  340 |     |             "Invalid validation duration"
  341 |     |         );
  342 |     | 
  343 |     |         // Note that registering without collateral does not enforce the subsidisation cap
  344 |     |         // or the validation duration limits.
  345 |     |         _register(
  346 |     |             msg.sender,
  347 |     |             nodeId,
  348 |     |             blsProofOfPossession,
  349 |     |             validationDuration,
  350 |     |             false,
  351 |     |             address(0),
  352 |     |             0,
  353 |     |             false
  354 |     |         );
  355 |     |     }
  356 |     | 
  357 |     |     /**
  358 |     |      * @notice Register a new node with a prevalidated QI deposit amount
  359 |     |      * @param  beneficiary User on whose behalf the registration is made
  360 |     |      * @param  nodeId Node ID of the validator
  361 |     |      * @param  blsProofOfPossession BLS proof of possession (public key + signature)
  362 |     |      * @param  validationDuration Duration of the validation in seconds
  363 |     |      * @param  qiAmount The amount of QI that was staked
  364 |     |      */
  365 |     |     function registerWithPrevalidatedQiStake(
  366 |     |         address beneficiary,
  367 |     |         string calldata nodeId,
  368 |     |         bytes calldata blsProofOfPossession,
  369 |     |         uint validationDuration,
  370 |     |         uint qiAmount
  371 |     |     ) external {
  372 |     |         require(
  373 | *   |             hasRole(ROLE_REGISTER_WITH_FLEXIBLE_PRICE_CHECK, msg.sender),
  374 |     |             "ROLE_REGISTER_WITH_FLEXIBLE_PRICE_CHECK"
  375 |     |         );
  376 |     | 
  377 | *   |         (, int256 avaxPrice, , uint avaxPriceUpdatedAt, ) = priceFeeds[AVAX].latestRoundData();
  378 | *   |         (, int256 qiPrice, , uint qiPriceUpdatedAt, ) = priceFeeds[address(qi)].latestRoundData();
  379 |     | 
  380 | *   |         require(avaxPrice > 0 && qiPrice > 0);
  381 | *   |         require(block.timestamp - avaxPriceUpdatedAt <= maxPriceAges[AVAX]);
  382 | *   |         require(block.timestamp - qiPriceUpdatedAt <= maxPriceAges[address(qi)]);
  383 |     | 
  384 |     |         // 200 AVAX + 1 AVAX fee
  385 | *   |         uint expectedQiAmount = uint(avaxPrice) * 201e18 / uint(qiPrice);
  386 |     | 
  387 | *   |         require(qiAmount >= expectedQiAmount * 9 / 10);
  388 |     | 
  389 | *   |         qi.safeTransferFrom(msg.sender, address(this), qiAmount);
  390 |     | 
  391 |     |         _registerWithChecks(
  392 |     |             beneficiary,
  393 |     |             nodeId,
  394 |     |             blsProofOfPossession,
  395 |     |             validationDuration,
  396 |     |             false,
  397 |     |             address(qi),
  398 |     |             qiAmount,
  399 | *   |             true
  400 |     |         );
  401 |     |     }
  402 |     | 
  403 |     |     /**
  404 |     |      * @notice To be called after the validation period has expired and the staker
  405 |     |      *         wants to redeem their deposited tokens and potential rewards.
  406 |     |      * @param  nodeId Node ID of the validator
  407 |     |      */
  408 |     |     function redeemAfterExpiry(string calldata nodeId) external nonReentrant whenNotPaused {
  409 |     |         uint registrationIndex = registrationIndicesByNodeId[nodeId];
  410 |     |         require(registrationIndex != 0);
  411 |     | 
  412 |     |         Registration storage registration = registrations[registrationIndex];
  413 |     | 
  414 |     |         require(registration.registerer == msg.sender);
  415 |     |         require(registration.withdrawable);
  416 |     | 
  417 |     |         // If feePaid is true and the registration is withdrawable, it must have been released
  418 |     |         // with the failed flag set, meaning that the validator could not be started and the
  419 |     |         // fee should be refunded.
  420 |     |         if (registration.feePaid) {
  421 |     |             if (registration.tokenDeposits.avaxAmount > 0) {
  422 |     |                 uint avaxDepositAmount = registration.tokenDeposits.avaxAmount;
  423 |     | 
  424 |     |                 minimumContractBalance -= avaxDepositAmount;
  425 |     | 
  426 |     |                 _deleteRegistration(nodeId);
  427 |     | 
  428 |     |                 (bool success, ) = payable(msg.sender).call{ value: avaxDepositAmount }("");
  429 |     |                 require(success);
  430 |     | 
  431 |     |                 emit Redeem(nodeId, avaxDepositAmount, address(0), 0);
  432 |     |             } else {
  433 |     |                 IERC20Upgradeable token = IERC20Upgradeable(registration.tokenDeposits.token);
  434 |     |                 uint tokenDepositAmount = registration.tokenDeposits.tokenAmount;
  435 |     | 
  436 |     |                 _deleteRegistration(nodeId);
  437 |     | 
  438 |     |                 token.safeTransfer(msg.sender, tokenDepositAmount);
  439 |     | 
  440 |     |                 emit Redeem(nodeId, 0, address(token), tokenDepositAmount);
  441 |     |             }
  442 |     | 
  443 |     |             return;
  444 |     |         }
  445 |     | 
  446 |     |         // tokenAmount is always denominated in QI tokens for stake model registrations
  447 |     |         uint qiDepositAmount = registration.tokenDeposits.tokenAmount;
  448 |     |         uint avaxDepositAmount = registration.tokenDeposits.avaxAmount;
  449 |     | 
  450 |     |         uint avaxRedemptionAmount;
  451 |     |         uint qiRedemptionAmount;
  452 |     | 
  453 |     |         // If a validator was slashed, the slash amount was already transferred to the
  454 |     |         // slashed token recipient. The remaining QI tokens are held in this contract.
  455 |     |         if (registration.slashed) {
  456 |     |             avaxRedemptionAmount = avaxDepositAmount - avaxDepositAmount * registration.avaxSlashPercentage / 10_000;
  457 |     |             qiRedemptionAmount = qiDepositAmount - qiDepositAmount * registration.qiSlashPercentage / 10_000;
  458 |     | 
  459 |     |             minimumContractBalance -= avaxRedemptionAmount;
  460 |     |         } else {
  461 |     |             avaxRedemptionAmount = avaxDepositAmount + registration.rewardAmount;
  462 |     |             qiRedemptionAmount = qiDepositAmount;
  463 |     | 
  464 |     |             if (qiRewardEligibilityByNodeId[nodeId]) {
  465 |     |                 qiRedemptionAmount += validatorRewarder.claimRewards(
  466 |     |                     registration.validationDuration,
  467 |     |                     qiDepositAmount
  468 |     |                 );
  469 |     |             }
  470 |     | 
  471 |     |             minimumContractBalance -= avaxRedemptionAmount;
  472 |     |         }
  473 |     | 
  474 |     |         _deleteRegistration(nodeId);
  475 |     | 
  476 |     |         qi.safeTransfer(msg.sender, qiRedemptionAmount);
  477 |     | 
  478 |     |         if (avaxRedemptionAmount > 0) {
  479 |     |             (bool success, ) = msg.sender.call{ value: avaxRedemptionAmount}("");
  480 |     |             require(success);
  481 |     |         }
  482 |     | 
  483 |     |         emit Redeem(nodeId, avaxRedemptionAmount, address(qi), qiRedemptionAmount);
  484 |     |     }
  485 |     | 
  486 |     |     /**
  487 |     |      * @notice Returns the number of registrations
  488 |     |      * @return Number of registrations
  489 |     |      */
  490 |     |     function getTotalRegistrations() external view returns (uint) {
  491 |     |         // Subtract 1 because the first registration is a dummy registration
  492 |     |         return registrations.length - 1;
  493 |     |     }
  494 |     | 
  495 |     |     /**
  496 |     |      * @notice Returns the number of available ERC-20 payment tokens for the fee model
  497 |     |      * @return Number of payment methods
  498 |     |      */
  499 |     |     function getTotalErc20PaymentMethods() external view returns (uint) {
  500 |     |         return paymentTokens.length();
  501 |     |     }
  502 |     | 
  503 |     |     /**
  504 |     |      * @notice Get a list of all supported ERC-20 payment token for the fee model
  505 |     |      * @return A list of supported payment token addresses
  506 |     |      */
  507 |     |     function getErc20PaymentMethods() external view returns (address[] memory) {
  508 |     |         return paymentTokens.values();
  509 |     |     }
  510 |     | 
  511 |     |     /**
  512 |     |      * @notice Returns an array of registrations made by the given account
  513 |     |      * @param  account Account to query
  514 |     |      * @param  from Index of the first registration to return (inclusive)
  515 |     |      * @param  to Index of the last registration to return (exclusive)
  516 |     |      * @return Array of registrations
  517 |     |      */
  518 |     |     function getRegistrationsByAccount(
  519 |     |         address account,
  520 |     |         uint from,
  521 |     |         uint to
  522 |     |     ) external view returns (Registration[] memory) {
  523 |     |         Registration[] memory accountRegistrations = new Registration[](to - from);
  524 |     | 
  525 |     |         for (uint i = from; i < to; ++i) {
  526 | *   |             accountRegistrations[i - from] = registrations[registrationIndicesByNodeId[registeredNodeIdsByAccount[account][i]]];
  527 |     |         }
  528 |     | 
  529 |     |         return accountRegistrations;
  530 |     |     }
  531 |     | 
  532 |     |     /**
  533 |     |      * @notice Returns the number of registrations made by the given account
  534 |     |      * @param  account Account to query
  535 |     |      * @return Number of registrations
  536 |     |      */
  537 |     |     function getAccountRegistrationCount(address account) external view returns (uint) {
  538 |     |         return registeredNodeIdsByAccount[account].length;
  539 |     |     }
  540 |     | 
  541 |     |     /**
  542 |     |      * @notice Get the registration fee in AVAX for a given validation duration
  543 |     |      * @param  validationDuration Validation duration in seconds
  544 |     |      * @return Registration fee in AVAX
  545 |     |      */
  546 |     |     function getRegistrationFee(uint validationDuration) external view returns (uint) {
  547 | *   |         return _getRegistrationFee(validationDuration);
  548 |     |     }
  549 |     | 
  550 |     |     /**
  551 |     |      * @notice Called to withdraw AVAX from the contract to start validation
  552 |     |      * @param  amount Amount of AVAX to be withdrawn
  553 |     |      */
  554 |     |     function withdraw(uint amount) external whenNotPaused {
  555 | *   |         require(hasRole(ROLE_WITHDRAW, msg.sender));
  556 |     | 
  557 | *   |         (bool success, ) = msg.sender.call{ value: amount }("");
  558 |     |         require(success);
  559 |     | 
  560 |     |         require(
  561 | *   |             address(this).balance >= minimumContractBalance,
  562 |     |             "Withdrawal amount too big"
  563 |     |         );
  564 |     | 
  565 | *   |         emit Withdraw(amount);
  566 |     |     }
  567 |     | 
  568 |     |     /**
  569 |     |      * @notice Called after the validation period has expired and the tokens become
  570 |     |      *         redeemable by the original staker.
  571 |     |      * @param  nodeId Node ID of the expired validator
  572 |     |      * @param  failed True if the validator could not be started, false otherwise
  573 |     |      */
  574 | *   |     function releaseLockedTokens(
  575 |     |         string calldata nodeId,
  576 |     |         bool failed
  577 |     |     ) external payable whenNotPaused nonReentrant {
  578 | *   |         require(hasRole(ROLE_RELEASE_LOCKED_TOKENS, msg.sender),"role error ");
  579 |     | 
  580 | *   |         uint registrationIndex = registrationIndicesByNodeId[nodeId];
  581 | *   |         require(registrationIndex != 0,"registrationIndex != 0");
  582 |     | 
  583 | *   |         Registration storage registration = registrations[registrationIndex];
  584 |     | 
  585 | *   |         require(!registration.withdrawable,"!registration.withdrawable");
  586 |     | 
  587 | *   |         emit RegistrationExpired(nodeId);
  588 |     | 
  589 |     |         // If the failed flag is set, this means that a validator could not be started for the
  590 |     |         // given node ID and the principal stake or fee should be returned to the user in whole.
  591 | *   |         if (failed) {
  592 | *   |             if (registration.feePaid) {
  593 | *   |                 require(msg.value == 0);
  594 |     | 
  595 | *   |                 totalSubsidisedAmount -= 2000e18;
  596 |     |             } else {
  597 |     |                 require(
  598 | *   |                     msg.value == registration.tokenDeposits.avaxAmount,
  599 |     |                     "Message value must match the AVAX deposit amount"
  600 |     |                 );
  601 |     | 
  602 |     |                 // Non-tokenised registrations do not count towards the subsidisation cap
  603 |     |                 // nor can have a non-zero AVAX deposit and should be deleted immediately.
  604 | *   |                 if (registration.tokenDeposits.tokenAmount == 0) {
  605 | *   |                     _deleteRegistration(nodeId);
  606 |     | 
  607 |     |                     return;
  608 |     |                 } else {
  609 | *   |                     minimumContractBalance += msg.value;
  610 | *   |                     totalSubsidisedAmount -= 2000e18 - msg.value;
  611 | *   |                     qiRewardEligibilityByNodeId[nodeId] = false;
  612 |     |                 }
  613 |     |             }
  614 |     | 
  615 |     |             registration.withdrawable = true;
  616 |     | 
  617 | *   |             return;
  618 |     |         }
  619 |     | 
  620 |     |         // If a fee was paid, the registration can be deleted immediately because
  621 |     |         // there is nothing for the user to claim afterwards.
  622 | *   |         if (registration.feePaid) {
  623 | *   |             require(msg.value == 0);
  624 |     | 
  625 | *   |             totalSubsidisedAmount -= 2000e18;
  626 |     | 
  627 | *   |             if (registration.tokenDeposits.avaxAmount > 0) {
  628 |     |                 uint avaxDepositAmount = registration.tokenDeposits.avaxAmount;
  629 |     | 
  630 | *   |                 minimumContractBalance -= avaxDepositAmount;
  631 |     | 
  632 | *   |                 _deleteRegistration(nodeId);
  633 |     | 
  634 | *   |                 (bool success, ) = FEE_RECIPIENT.call{ value: avaxDepositAmount }("");
  635 |     |                 require(success);
  636 |     |             } else {
  637 | *   |                 IERC20Upgradeable token = IERC20Upgradeable(registration.tokenDeposits.token);
  638 | *   |                 uint tokenDepositAmount = registration.tokenDeposits.tokenAmount;
  639 |     | 
  640 | *   |                 _deleteRegistration(nodeId);
  641 |     | 
  642 | *   |                 token.safeTransfer(FEE_RECIPIENT, tokenDepositAmount);
  643 |     |             }
  644 |     | 
  645 | *   |             return;
  646 |     |         }
  647 |     | 
  648 |     |         // If a token deposit was not made, this is a registration by a privileged
  649 |     |         // account. These registrations cannot be rewarded nor can they be slashed.
  650 |     |         // Non-tokenised registrations do not count towards the subsidisation cap.
  651 | *   |         if (registration.tokenDeposits.avaxAmount == 0 && registration.tokenDeposits.tokenAmount == 0) {
  652 | *   |             require(msg.value == 0);
  653 |     | 
  654 |     |             _deleteRegistration(nodeId);
  655 |     | 
  656 |     |             return;
  657 |     |         }
  658 |     | 
  659 | *   |         registration.withdrawable = true;
  660 |     | 
  661 | *   |         totalSubsidisedAmount -= 2000e18 - registration.tokenDeposits.avaxAmount;
  662 |     | 
  663 | *   |         if (qiRewardEligibilityByNodeId[nodeId]) {
  664 | *   |             require(msg.value == 0);
  665 |     | 
  666 | *   |             uint fee = registration.tokenDeposits.tokenAmount / 201;
  667 | *   |             registration.tokenDeposits.tokenAmount -= fee;
  668 |     | 
  669 | *   |             qi.safeTransfer(FEE_RECIPIENT, fee);
  670 |     | 
  671 | *   |             emit ValidatorRewarded(nodeId, 0);
  672 | *   |         } else if (msg.value > registration.tokenDeposits.avaxAmount) {
  673 | *   |             uint rewards = msg.value - registration.tokenDeposits.avaxAmount;
  674 |     | 
  675 | *   |             registration.rewardAmount = rewards;
  676 | *   |             minimumContractBalance += msg.value;
  677 |     | 
  678 | *   |             emit ValidatorRewarded(nodeId, rewards);
  679 |     |         } else {
  680 | *   |             require(msg.value == registration.tokenDeposits.avaxAmount);
  681 |     | 
  682 |     |             registration.slashed = true;
  683 |     | 
  684 |     |             uint qiSlashAmount;
  685 | *   |             uint avaxSlashAmount;
  686 |     | 
  687 | *   |             if (registration.qiSlashPercentage > 0) {
  688 |     |                 // tokenDeposits.tokenAmount is always denominated in QI for stake model registrations
  689 | *   |                 qiSlashAmount = registration.tokenDeposits.tokenAmount * registration.qiSlashPercentage / 10_000;
  690 |     | 
  691 |     |                 qi.safeTransfer(SLASHED_TOKEN_RECIPIENT, qiSlashAmount);
  692 |     |             }
  693 |     | 
  694 | *   |             if (registration.avaxSlashPercentage > 0) {
  695 |     |                 avaxSlashAmount = registration.tokenDeposits.avaxAmount * registration.avaxSlashPercentage / 10_000;
  696 |     | 
  697 |     |                 minimumContractBalance += msg.value - avaxSlashAmount;
  698 |     | 
  699 |     |                 (bool success, ) = SLASHED_TOKEN_RECIPIENT.call{ value: avaxSlashAmount }("");
  700 |     |                 require(success);
  701 |     |             } else {
  702 | *   |                 minimumContractBalance += msg.value;
  703 |     |             }
  704 |     | 
  705 | *   |             emit ValidatorSlashed(nodeId, qiSlashAmount, avaxSlashAmount);
  706 |     |         }
  707 |     |     }
  708 |     | 
  709 |     |     /**
  710 |     |      * @notice Pause new registrations, withdrawals, releases, and redemptions.
  711 |     |      */
  712 |     |     function pause() external {
  713 |     |         require(hasRole(ROLE_PAUSE, msg.sender));
  714 |     | 
  715 |     |         _pause();
  716 |     |     }
  717 |     | 
  718 |     |     /**
  719 |     |      * @notice Resume new registrations, withdrawals, releses, and redemptions.
  720 |     |      */
  721 |     |     function unpause() external {
  722 |     |         require(hasRole(ROLE_UNPAUSE, msg.sender));
  723 |     | 
  724 |     |         _unpause();
  725 |     |     }
  726 |     | 
  727 |     |     /**
  728 |     |      * @notice Change the QI slash percentage
  729 |     |      * @param  newPercentage The new percentage in bps
  730 |     |      */
  731 |     |     function setQiSlashPercentage(uint newPercentage) external {
  732 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  733 |     |         require(newPercentage <= 10_000);
  734 |     | 
  735 |     |         uint oldPercentage = qiSlashPercentage;
  736 |     |         qiSlashPercentage = newPercentage;
  737 |     | 
  738 |     |         emit QiSlashPercentageChanged(oldPercentage, newPercentage);
  739 |     |     }
  740 |     | 
  741 |     |     /**
  742 |     |      * @notice Change the AVAX slash percentage
  743 |     |      * @param  newPercentage The new percentage in bps
  744 |     |      */
  745 |     |     function setAvaxSlashPercentage(uint newPercentage) external {
  746 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  747 |     |         require(newPercentage <= 10_000);
  748 |     | 
  749 |     |         uint oldPercentage = avaxSlashPercentage;
  750 |     |         avaxSlashPercentage = newPercentage;
  751 |     | 
  752 |     |         emit AvaxSlashPercentageChanged(oldPercentage, newPercentage);
  753 |     |     }
  754 |     | 
  755 |     |     /**
  756 |     |      * @notice Change the protocol maximum AVAX subsidisation amount
  757 |     |      * @param  newMaximumSubsidisationAmount New maximum subsidisation amount in AVAX (18 decimals)
  758 |     |      */
  759 |     |     function setMaximumSubsidisationAmount(uint newMaximumSubsidisationAmount) external {
  760 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  761 |     | 
  762 |     |         uint oldMaximumSubsidisationAmount = maximumSubsidisationAmount;
  763 |     |         maximumSubsidisationAmount = newMaximumSubsidisationAmount;
  764 |     | 
  765 |     |         emit MaximumSubsidisationAmountChanged(
  766 |     |             oldMaximumSubsidisationAmount,
  767 |     |             newMaximumSubsidisationAmount
  768 |     |         );
  769 |     |     }
  770 |     | 
  771 |     |     /**
  772 |     |      * @notice Update the QI price multiplier used for fee payments in QI
  773 |     |      * @param newQiPriceMultiplier New price multiplier in bps
  774 |     |      */
  775 |     |     function setQiPriceMultiplier(uint newQiPriceMultiplier) external {
  776 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  777 |     |         require(newQiPriceMultiplier <= 10_000);
  778 |     | 
  779 |     |         uint oldQiPriceMultiplier = qiPriceMultiplier;
  780 |     |         qiPriceMultiplier = newQiPriceMultiplier;
  781 |     | 
  782 |     |         emit QiPriceMultiplierUpdated(oldQiPriceMultiplier, newQiPriceMultiplier);
  783 |     |     }
  784 |     | 
  785 |     |     /**
  786 |     |      * @notice Add a new fee payment token option
  787 |     |      * @param  token ERC-20 token address
  788 |     |      * @param  priceFeedAddress Chainlink price feed address for the token
  789 |     |      * @param  maxPriceAge Maximum price feed response age
  790 |     |      */
  791 |     |     function addPaymentToken(
  792 |     |         address token,
  793 |     |         address priceFeedAddress,
  794 |     |         uint maxPriceAge
  795 |     |     ) external {
  796 | *   |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  797 | *   |         require(token != address(0));
  798 | *   |         require(!paymentTokens.contains(token));
  799 |     | 
  800 |     |         IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);
  801 |     | 
  802 |     |         paymentTokens.add(token);
  803 | *   |         priceFeeds[token] = priceFeed;
  804 | *   |         maxPriceAges[token] = maxPriceAge;
  805 |     | 
  806 | *   |         (, int256 price, , uint updatedAt, ) = priceFeed.latestRoundData();
  807 | *   |         require(price > 0);
  808 | *   |         require(block.timestamp - updatedAt <= maxPriceAge);
  809 |     | 
  810 | *   |         emit PaymentTokenAdded(token);
  811 |     |     }
  812 |     | 
  813 |     |     /**
  814 |     |      * @notice Remove an existing fee payment token option
  815 |     |      * @param  token Token to remove
  816 |     |      */
  817 |     |     function removePaymentToken(address token) external {
  818 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  819 |     |         require(paymentTokens.contains(token));
  820 |     | 
  821 |     |         // AVAX and QI price feed configuration must not be deleted
  822 |     |         if (token != AVAX && token != address(qi)) {
  823 |     |             delete priceFeeds[token];
  824 |     |             delete maxPriceAges[token];
  825 |     |         }
  826 |     | 
  827 |     |         paymentTokens.remove(token);
  828 |     | 
  829 |     |         emit PaymentTokenRemoved(token);
  830 |     |     }
  831 |     | 
  832 |     |     /**
  833 |     |      * @notice Update the price feed configuration for a pre-existing payment token
  834 |     |      * @param  token ERC-20 token address
  835 |     |      * @param  priceFeedAddress Chainlink price feed address for the token
  836 |     |      * @param  maxPriceAge Maximum price feed response age
  837 |     |      */
  838 |     |     function configurePriceFeed(
  839 |     |         address token,
  840 |     |         address priceFeedAddress,
  841 |     |         uint maxPriceAge
  842 |     |     ) external {
  843 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  844 |     | 
  845 |     |         address oldPriceFeed = address(priceFeeds[token]);
  846 |     |         uint oldPriceMaxAge = maxPriceAges[token];
  847 |     | 
  848 |     |         require(oldPriceFeed != address(0));
  849 |     | 
  850 |     |         IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);
  851 |     | 
  852 |     |         priceFeeds[token] = priceFeed;
  853 |     |         maxPriceAges[token] = maxPriceAge;
  854 |     | 
  855 | *   |         (, int256 price, , uint updatedAt, ) = priceFeed.latestRoundData();
  856 |     |         require(price > 0);
  857 |     |         require(block.timestamp - updatedAt <= maxPriceAge);
  858 |     | 
  859 |     |         emit PriceFeedChanged(token, oldPriceFeed, priceFeedAddress, oldPriceMaxAge, maxPriceAge);
  860 |     |     }
  861 |     | 
  862 |     |     /**
  863 |     |      * @notice Change the required AVAX deposit amount for a registration
  864 |     |      * @param  newMinimumAvaxDeposit New minimum AVAX deposit amount (18 decimals)
  865 |     |      * @param  newMaximumAvaxDeposit New maximum AVAX deposit amount (18 decimals)
  866 |     |      */
  867 |     |     function setAvaxDepositRange(uint newMinimumAvaxDeposit, uint newMaximumAvaxDeposit) external {
  868 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  869 |     |         require(newMinimumAvaxDeposit <= newMaximumAvaxDeposit);
  870 |     | 
  871 |     |         uint oldMinimumAvaxDeposit = minimumAvaxDeposit;
  872 |     |         uint oldMaximumAvaxDeposit = maximumAvaxDeposit;
  873 |     | 
  874 |     |         minimumAvaxDeposit = newMinimumAvaxDeposit;
  875 |     |         maximumAvaxDeposit = newMaximumAvaxDeposit;
  876 |     | 
  877 |     |         emit AvaxDepositRangeUpdated(
  878 |     |             oldMinimumAvaxDeposit,
  879 |     |             minimumAvaxDeposit,
  880 |     |             oldMaximumAvaxDeposit,
  881 |     |             maximumAvaxDeposit
  882 |     |         );
  883 |     |     }
  884 |     | 
  885 |     |     /**
  886 |     |      * @notice Set the ValidatorRewarder contract address
  887 |     |      * @param  newValidatorRewarder ValidatorRewarder contract address
  888 |     |      */
  889 |     |     function setValidatorRewarder(address newValidatorRewarder) external {
  890 |     |         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
  891 |     | 
  892 |     |         validatorRewarder = ValidatorRewarder(newValidatorRewarder);
  893 |     |     }
  894 |     | 
  895 |     |     /**
  896 |     |      * @notice Store the registration using _register after validating the subsidisation
  897 |     |      *         cap and validation duration.
  898 |     |      * @param  beneficiary The beneficiary of the registration
  899 |     |      * @param  nodeId ID of the node to register
  900 |     |      * @param  blsProofOfPossession BLS proof of possession (public key + signature)
  901 |     |      * @param  validationDuration Duration of the validation period
  902 |     |      * @param  feePaid Whether or not the fee was paid
  903 |     |      * @param  token ERC-20 payment token address
  904 |     |      * @param  tokenAmount Amount of ERC-20 tokens deposited
  905 |     |      * @param  isEligibleForQiRewards True if the node is eligible for QI rewards at the end of the validation
  906 |     |      */
  907 |     |     function _registerWithChecks(
  908 |     |         address beneficiary,
  909 |     |         string calldata nodeId,
  910 |     |         bytes calldata blsProofOfPossession,
  911 |     |         uint validationDuration,
  912 |     |         bool feePaid,
  913 |     |         address token,
  914 |     |         uint tokenAmount,
  915 |     |         bool isEligibleForQiRewards
  916 |     |     ) internal {
  917 |     |         uint subsidisationAmount;
  918 |     |         if (feePaid) {
  919 | *   |             subsidisationAmount = 2000e18;
  920 |     |         } else {
  921 | *   |             subsidisationAmount = 2000e18 - msg.value;
  922 |     |         }
  923 |     | 
  924 |     |         require(
  925 | *   |             totalSubsidisedAmount + subsidisationAmount <= maximumSubsidisationAmount,
  926 |     |             "Subsidisation cap exceeded"
  927 |     |         );
  928 |     | 
  929 |     |         require(
  930 | *   |             validationDuration == VALIDATION_DURATION_TWO_WEEKS ||
  931 | *   |             validationDuration == VALIDATION_DURATION_FOUR_WEEKS ||
  932 | *   |             validationDuration == VALIDATION_DURATION_EIGHT_WEEKS ||
  933 | *   |             validationDuration == VALIDATION_DURATION_TWELVE_WEEKS,
  934 |     |             "Invalid staking duration"
  935 |     |         );
  936 |     | 
  937 | *   |         totalSubsidisedAmount += subsidisationAmount;
  938 |     | 
  939 |     |         _register(
  940 |     |             beneficiary,
  941 |     |             nodeId,
  942 |     |             blsProofOfPossession,
  943 |     |             validationDuration,
  944 |     |             feePaid,
  945 |     |             token,
  946 |     |             tokenAmount,
  947 |     |             isEligibleForQiRewards
  948 |     |         );
  949 |     |     }
  950 |     | 
  951 |     |     /**
  952 |     |      * @notice Store the registration
  953 |     |      * @param  beneficiary The beneficiary of the registration
  954 |     |      * @param  nodeId ID of the node to register
  955 |     |      * @param  blsProofOfPossession BLS proof of possession (public key + signature)
  956 |     |      * @param  validationDuration Duration of the validation period
  957 |     |      * @param  feePaid Whether or not the fee was paid
  958 |     |      * @param  token Payment token address
  959 |     |      * @param  tokenAmount Amount of ERC-20 tokens deposited
  960 |     |      * @param  isEligibleForQiRewards True if the node is eligible for QI rewards at the end of the validation
  961 |     |      */
  962 |     |     function _register(
  963 |     |         address beneficiary,
  964 |     |         string calldata nodeId,
  965 |     |         bytes calldata blsProofOfPossession,
  966 |     |         uint validationDuration,
  967 |     |         bool feePaid,
  968 |     |         address token,
  969 |     |         uint tokenAmount,
  970 |     |         bool isEligibleForQiRewards
  971 |     |     ) internal whenNotPaused {
  972 |     |         // uint registrationIndex = registrationIndicesByNodeId[nodeId];
  973 |     |         // require(
  974 |     |         //     registrationIndex == 0 && bytes(nodeId).length != 0,
  975 |     |         //     "Node already registered"
  976 |     |         // );
  977 |     | 
  978 | *   |         require(blsProofOfPossession.length == 144);
  979 |     | 
  980 | *   |         registrationIndicesByNodeId[nodeId] = registrations.length;
  981 | *   |         registrations.push(
  982 | *   |             Registration(
  983 |     |                 beneficiary,
  984 |     |                 nodeId,
  985 |     |                 validationDuration,
  986 |     |                 feePaid,
  987 | *   |                 TokenDepositDetails(
  988 |     |                     msg.value, // avax amount
  989 |     |                     token,
  990 |     |                     tokenAmount
  991 |     |                 ),
  992 |     |                 0,
  993 | *   |                 qiSlashPercentage,
  994 | *   |                 avaxSlashPercentage,
  995 |     |                 false,
  996 |     |                 false
  997 |     |             )
  998 |     |         );
  999 |     | 
 1000 | *   |         blsProofOfPossessionByNodeId[nodeId] = blsProofOfPossession;
 1001 | *   |         qiRewardEligibilityByNodeId[nodeId] = isEligibleForQiRewards;
 1002 |     | 
 1003 | *   |         accountRegistrationIndicesByNodeId[nodeId] = registeredNodeIdsByAccount[beneficiary].length;
 1004 |     |         registeredNodeIdsByAccount[beneficiary].push(nodeId);
 1005 |     | 
 1006 | *   |         emit NewRegistration(
 1007 |     |             beneficiary,
 1008 |     |             nodeId,
 1009 |     |             blsProofOfPossession,
 1010 |     |             validationDuration,
 1011 |     |             feePaid,
 1012 |     |             msg.value,
 1013 |     |             token,
 1014 |     |             tokenAmount
 1015 |     |         );
 1016 |     |     }
 1017 |     | 
 1018 |     |     /**
 1019 |     |      * @dev   Remove a node registration. Note that all tokens must have been
 1020 |     |      *        sent back to the original staker before deleting the registration
 1021 |     |      *        entry in order not to lose the tokens.
 1022 |     |      * @param nodeId Node ID to delete
 1023 |     |      */
 1024 | *   |     function _deleteRegistration(string calldata nodeId) internal {
 1025 | *   |         uint registrationIndex = registrationIndicesByNodeId[nodeId];
 1026 | *   |         require(registrationIndex != 0);
 1027 |     | 
 1028 | *   |         address registerer = registrations[registrationIndex].registerer;
 1029 |     | 
 1030 | *   |         uint accountRegistrationIndex = accountRegistrationIndicesByNodeId[nodeId];
 1031 | *   |         uint accountRegistrationLastIndex = registeredNodeIdsByAccount[registerer].length - 1;
 1032 |     | 
 1033 | *   |         if (accountRegistrationIndex != accountRegistrationLastIndex) {
 1034 | *   |             string memory lastNodeId = registeredNodeIdsByAccount[registerer][accountRegistrationLastIndex];
 1035 | *   |             registeredNodeIdsByAccount[registerer][accountRegistrationIndex] = lastNodeId;
 1036 |     |             accountRegistrationIndicesByNodeId[lastNodeId] = accountRegistrationIndex;
 1037 |     |         }
 1038 |     | 
 1039 |     |         registeredNodeIdsByAccount[registerer].pop();
 1040 |     | 
 1041 |     |         delete accountRegistrationIndicesByNodeId[nodeId];
 1042 | *   |         delete blsProofOfPossessionByNodeId[nodeId];
 1043 | *   |         delete qiRewardEligibilityByNodeId[nodeId];
 1044 |     | 
 1045 |     |         uint totalRegistrations = registrations.length - 1;
 1046 | *   |         if (registrationIndex != totalRegistrations) {
 1047 | *   |             string memory lastNodeId = registrations[totalRegistrations].nodeId;
 1048 | *   |             registrations[registrationIndex] = registrations[totalRegistrations];
 1049 |     |             registrationIndicesByNodeId[lastNodeId] = registrationIndex;
 1050 |     |         }
 1051 |     | 
 1052 |     |         registrations.pop();
 1053 |     | 
 1054 |     |         delete registrationIndicesByNodeId[nodeId];
 1055 |     | 
 1056 | *   |         emit RegistrationDeleted(nodeId);
 1057 |     |     }
 1058 |     | 
 1059 |     |     /**
 1060 |     |      * @notice Get the registration fee in AVAX for a given validation duration
 1061 |     |      * @param  validationDuration Validation duration in seconds
 1062 |     |      * @return Registration fee in AVAX
 1063 |     |      */
 1064 | *   |     function _getRegistrationFee(uint validationDuration) internal view returns (uint) {
 1065 | *   |         if (validationDuration == VALIDATION_DURATION_TWO_WEEKS) {
 1066 | *   |             return 8e18;
 1067 |     |         }
 1068 |     | 
 1069 | *   |         if (validationDuration == VALIDATION_DURATION_FOUR_WEEKS) {
 1070 | *   |             return 15e18;
 1071 |     |         }
 1072 |     | 
 1073 | *   |         if (validationDuration == VALIDATION_DURATION_EIGHT_WEEKS) {
 1074 | *   |             return 28e18;
 1075 |     |         }
 1076 |     | 
 1077 | *   |         if (validationDuration == VALIDATION_DURATION_TWELVE_WEEKS) {
 1078 | *   |             return 40e18;
 1079 |     |         }
 1080 |     | 
 1081 |     |         revert("Invalid validation duration");
 1082 |     |     }
 1083 |     | }

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/src/IgniteStorage.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
   5 |     | import "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol";
   6 |     | 
   7 |     | import "./IStakedAvax.sol";
   8 |     | import "./IPriceFeed.sol";
   9 |     | import "./ValidatorRewarder.sol";
  10 |     | 
  11 |     | 
  12 |     | contract IgniteStorage {
  13 |     |     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
  14 |     | 
  15 |     |     /// @dev List of all supported ERC-20 payment options for the fee model
  16 |     |     EnumerableSetUpgradeable.AddressSet paymentTokens;
  17 |     | 
  18 |     |     /// @dev Chainlink price feeds for each payment option
  19 |     |     mapping(address => IPriceFeed) public priceFeeds;
  20 |     | 
  21 |     |     /// @dev Max Chainlink price feed response age for each token
  22 |     |     mapping(address => uint) public maxPriceAges;
  23 |     | 
  24 |     |     struct TokenDepositDetails {
  25 |     |         /// @dev AVAX deposit amount
  26 |     |         uint avaxAmount;
  27 |     | 
  28 |     |         /// @dev Address of the deposited ERC-20 token (optional)
  29 |     |         address token;
  30 |     | 
  31 |     |         /// @dev Amount of the deposited ERC-20 token (must be zero if no token address is given)
  32 |     |         uint tokenAmount;
  33 |     |     }
  34 |     | 
  35 |     |     struct Registration {
  36 |     |         /// @dev The user who registered the node ID in Ignite
  37 |     |         address registerer;
  38 |     | 
  39 |     |         /// @dev The node ID
  40 |     |         string nodeId;
  41 |     | 
  42 |     |         /// @dev The requested validation duration in seconds
  43 |     |         uint validationDuration;
  44 |     | 
  45 |     |         /// @dev True if the registration was set up by paying a fee
  46 |     |         bool feePaid;
  47 |     | 
  48 |     |         /// @dev AVAX and ERC-20 token deposit amounts
  49 |     |         TokenDepositDetails tokenDeposits;
  50 |     | 
  51 |     |         /// @dev The amount of AVAX rewarded to the validator
  52 |     |         uint rewardAmount;
  53 |     | 
  54 |     |         /// @dev The percentage (in bps) of QI that can be slashed for this registration
  55 |     |         uint qiSlashPercentage;
  56 |     | 
  57 |     |         /// @dev The percentage (in bps) of AVAX that can be slashed for this registration
  58 |     |         uint avaxSlashPercentage;
  59 |     | 
  60 |     |         /// @dev Whether or not the validator has been slashed
  61 |     |         bool slashed;
  62 |     | 
  63 |     |         /// @dev Whether or not the registration has expired and the tokens can be withdrawn
  64 |     |         bool withdrawable;
  65 |     |     }
  66 |     | 
  67 |     |     /// @dev The sAVAX contract
  68 |     |     IStakedAvax public sAVAX;
  69 |     | 
  70 |     |     /// @dev The QI token contract
  71 |     |     IERC20Upgradeable public qi;
  72 |     | 
  73 |     |     /// @dev An array of all registrations
  74 | *   |     Registration[] public registrations;
  75 |     | 
  76 |     |     /// @dev Node ID to registrations array index
  77 | *   |     mapping(string => uint) public registrationIndicesByNodeId;
  78 |     | 
  79 |     |     /// @dev Registered node IDs per account
  80 |     |     mapping(address => string[]) public registeredNodeIdsByAccount;
  81 |     | 
  82 |     |     /// @dev Node ID to registeredNodeIdsByAccount index
  83 |     |     mapping(string => uint) public accountRegistrationIndicesByNodeId;
  84 |     | 
  85 |     |     /// @dev The total amount of AVAX that BENQI has subsidised for validation
  86 |     |     uint public totalSubsidisedAmount;
  87 |     | 
  88 |     |     /// @dev The maximum amount of AVAX that BENQI subsidises for validation
  89 |     |     uint public maximumSubsidisationAmount;
  90 |     | 
  91 |     |     /// @dev The amount QI (in bps) that can be slashed
  92 |     |     uint public qiSlashPercentage;
  93 |     | 
  94 |     |     /// @dev The amount of AVAX (in bps) that can be slashed
  95 |     |     uint public avaxSlashPercentage;
  96 |     | 
  97 |     |     /// @dev The minimum contract AVAX balance that must not be subceeded
  98 | *   |     uint public minimumContractBalance;
  99 |     | 
 100 |     |     /// @dev The minimum amount of AVAX needed to register a validator
 101 |     |     uint public minimumAvaxDeposit;
 102 |     | 
 103 |     |     /// @dev The maximum amount of AVAX that can be used to register a validator
 104 |     |     uint public maximumAvaxDeposit;
 105 |     | 
 106 |     |     /// @dev Price multiplier used for fee payments in QI (in bps)
 107 |     |     uint public qiPriceMultiplier;
 108 |     | 
 109 |     |     /// @dev BLS proof of possession for registered nodes
 110 |     |     mapping(string => bytes) public blsProofOfPossessionByNodeId;
 111 |     | 
 112 |     |     /// @dev Rewarder contract for extra QI validation rewards
 113 |     |     ValidatorRewarder public validatorRewarder;
 114 |     | 
 115 |     |     /// @dev Whether or not a validator should be eligible for extra QI rewards after expiry
 116 | *   |     mapping(string => bool) public qiRewardEligibilityByNodeId;
 117 |     | }
 118 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/src/ValidatorRewarder.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8;
   3 |     | 
   4 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
   5 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
   6 |     | import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   7 |     | import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
   8 |     | import "./ValidatorRewarderStorage.sol";
   9 |     | 
  10 |     | /// @notice Thrown if a privileged function is called without appropriate access rights
  11 |     | error Unauthorized();
  12 |     | 
  13 |     | contract ValidatorRewarder is
  14 |     |     AccessControlUpgradeable,
  15 |     |     PausableUpgradeable,
  16 |     |     ValidatorRewarderStorage
  17 |     | {
  18 |     |     using SafeERC20Upgradeable for IERC20Upgradeable;
  19 |     | 
  20 |     |     bytes32 public constant ROLE_WITHDRAW = keccak256("ROLE_WITHDRAW");
  21 |     |     bytes32 public constant ROLE_PAUSE = keccak256("ROLE_PAUSE");
  22 |     |     bytes32 public constant ROLE_UNPAUSE = keccak256("ROLE_UNPAUSE");
  23 |     | 
  24 |     |     /// @notice Emitted when rewards are claimed
  25 |     |     event ClaimRewards(uint amount);
  26 |     | 
  27 |     |     /// @notice Emitted when the target APR is changed
  28 |     |     event NewTargetApr(uint oldTargetApr, uint newTargetApr);
  29 |     | 
  30 |     |     /// @notice Emitted when QI is withdrawn from the rewarder contract by an admin
  31 |     |     event Withdraw(uint amount);
  32 |     | 
  33 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  34 |     |     constructor() {
  35 |     |         _disableInitializers();
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Set the initial contract parameters
  40 |     |      * @param _qi The QI token address
  41 |     |      * @param _ignite The Ignite contract address
  42 |     |      * @param _targetApr Target QI reward APR (bps)
  43 |     |      * @param _admin Contract owner address
  44 |     |      */
  45 |     |     function initialize(
  46 |     |         address _qi,
  47 |     |         address _ignite,
  48 |     |         uint _targetApr,
  49 |     |         address _admin
  50 |     |     ) initializer public {
  51 |     |         __AccessControl_init();
  52 |     |         __Pausable_init();
  53 |     | 
  54 |     |         _grantRole(DEFAULT_ADMIN_ROLE, _admin);
  55 |     | 
  56 |     |         qi = IERC20Upgradeable(_qi);
  57 |     |         ignite = _ignite;
  58 |     |         targetApr = _targetApr;
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice Claim QI rewards after validation expiry
  63 |     |      * @param validationDuration Validation duration (seconds)
  64 |     |      * @param stakeAmount QI stake amount (18 decimals)
  65 |     |      */
  66 |     |     function claimRewards(uint validationDuration, uint stakeAmount) external whenNotPaused returns (uint) {
  67 |     |         if (msg.sender != ignite) {
  68 |     |             revert Unauthorized();
  69 |     |         }
  70 |     | 
  71 |     |         uint rewardAmount = _calculateRewardAmount(validationDuration, stakeAmount);
  72 |     | 
  73 |     |         qi.safeTransfer(msg.sender, rewardAmount);
  74 |     | 
  75 |     |         emit ClaimRewards(rewardAmount);
  76 |     | 
  77 |     |         return rewardAmount;
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @notice Claim QI rewards after validation expiry
  82 |     |      * @param validationDuration Validation duration (seconds)
  83 |     |      * @param stakeAmount QI stake amount (18 decimals)
  84 |     |      */
  85 |     |     function calculateRewardAmount(uint validationDuration, uint stakeAmount) external view returns (uint) {
  86 |     |         return _calculateRewardAmount(validationDuration, stakeAmount);
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @notice Claim QI rewards after validation expiry
  91 |     |      * @param validationDuration Validation duration (seconds)
  92 |     |      * @param stakeAmount QI stake amount (18 decimals)
  93 |     |      */
  94 |     |     function _calculateRewardAmount(uint validationDuration, uint stakeAmount) internal view returns (uint) {
  95 |     |         return stakeAmount * targetApr * validationDuration / 10_000 / 60 / 60 / 24 / 365;
  96 |     |     }
  97 |     | 
  98 |     |     /*
  99 |     |      * @notice Withdraw QI from the contract
 100 |     |      * @param amount QI amount
 101 |     |      */
 102 |     |     function withdraw(uint amount) external {
 103 |     |         if (!hasRole(ROLE_WITHDRAW, msg.sender)) {
 104 |     |             revert Unauthorized();
 105 |     |         }
 106 |     | 
 107 |     |         qi.safeTransfer(msg.sender, amount);
 108 |     | 
 109 |     |         emit Withdraw(amount);
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @notice Set the reward APR
 114 |     |      * @param newTargetApr New APR (bps)
 115 |     |      */
 116 |     |     function setTargetApr(uint newTargetApr) external {
 117 |     |         if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {
 118 |     |             revert Unauthorized();
 119 |     |         }
 120 |     | 
 121 |     |         emit NewTargetApr(targetApr, newTargetApr);
 122 |     | 
 123 |     |         targetApr = newTargetApr;
 124 |     |     }
 125 |     | 
 126 |     |     /*
 127 |     |      * @notice Pause reward claims
 128 |     |      */
 129 |     |     function pause() external {
 130 |     |         if (!hasRole(ROLE_PAUSE, msg.sender)) {
 131 |     |             revert Unauthorized();
 132 |     |         }
 133 |     | 
 134 |     |         _pause();
 135 |     |     }
 136 |     | 
 137 |     |     /*
 138 |     |      * @notice Resume reward claims
 139 |     |      */
 140 |     |     function unpause() external {
 141 |     |         if (!hasRole(ROLE_PAUSE, msg.sender)) {
 142 |     |             revert Unauthorized();
 143 |     |         }
 144 |     | 
 145 |     |         _unpause();
 146 |     |     }
 147 |     | }
 148 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/src/ValidatorRewarderStorage.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
  5 |     | 
  6 |     | contract ValidatorRewarderStorage {
  7 |     |     /// @notice The QI token
  8 |     |     IERC20Upgradeable public qi;
  9 |     | 
 10 |     |     /// @notice The Ignite contract address
 11 |     |     address public ignite;
 12 |     | 
 13 |     |     /// @notice Target APR (bps)
 14 |     |     uint public targetApr;
 15 |     | }
 16 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/chiemara/BeforeAfter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Setup} from "./Setup.sol";
  5 |     | 
  6 |     | // ghost variables for tracking state variable values before and after function calls
  7 |     | abstract contract BeforeAfter is Setup {
  8 |     |     // struct Vars {
  9 |     |     //     uint256 counter_number;
 10 |     |     // }
 11 |     | 
 12 |     |     // Vars internal _before;
 13 |     |     // Vars internal _after;
 14 |     | 
 15 |     |     function __before() internal {
 16 |     |         // _before.counter_number = counter.number();
 17 |     |     }
 18 |     | 
 19 |     |     function __after() internal {
 20 |     |         // _after.counter_number = counter.number();
 21 |     |     }
 22 |     | }

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/chiemara/CryticTester.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {TargetFunctions} from "./TargetFunctions.sol";
  5 |     | import {CryticAsserts} from "@chimera/CryticAsserts.sol";
  6 |     | 
  7 |     | // echidna . --contract CryticTester --config echidna.yaml
  8 |     | // medusa fuzz
  9 | *r  | contract CryticTester is TargetFunctions, CryticAsserts {
 10 |     |     constructor() payable {
 11 |     |         setup();
 12 |     |     }
 13 |     | }

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/chiemara/Properties.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Asserts} from "@chimera/Asserts.sol";
  5 |     | import {BeforeAfter} from "./BeforeAfter.sol";
  6 |     | 
  7 |     | import {IgniteStorage} from "../../src/IgniteStorage.sol";
  8 |     | event LogAsad(uint256);
  9 |     | 
 10 |     | abstract contract Properties is BeforeAfter, Asserts {
 11 |     |    function echidna_check_eth_balance() external  view returns(bool){
 12 |     |         return address(ignite).balance == totalEthStaked;
 13 |     |     }
 14 |     |    function echidna_check_minimum_eth_balance() external  view returns(bool){
 15 | *   |         return ignite.minimumContractBalance() == gostMinimumContractBalance;
 16 |     |     }
 17 |     |    function echidna_check_qi_balance() external view returns(bool){
 18 |     |         return  qi.balanceOf(address(ignite)) ==  totalQIStaked;
 19 |     |     }
 20 |     |    function echidna_check_fail_registration_withdrawal() external view returns(bool){
 21 |     |         if(releaseLockTokenFailedCalled){
 22 |     |             for(uint i = 0; i < failRegistrationIndices.length; i++){
 23 |     |                 (,,,,,,,,,bool withdrawable) = ignite.registrations(failRegistrationIndices[i]);
 24 |     |                     if(!withdrawable){
 25 |     |                         return false;
 26 |     |                     }   
 27 |     |             }
 28 |     |         }
 29 |     |         return true;
 30 |     |     }
 31 |     |     function echidna_check_success_registration_withdrawal() external  returns(bool){
 32 |     |         if(releaseLockTokenSuccessCalled){
 33 |     |         emit LogAsad(avaxFee);
 34 |     |         emit LogAsad(tokenFee);
 35 |     |             return address(FEE_RECIPIENT).balance == avaxFee && qi.balanceOf(FEE_RECIPIENT) == tokenFee;
 36 |     |         }
 37 |     |         return true;
 38 |     |     }
 39 |     |     function echidna_check_success_slashed() external view returns(bool){
 40 |     |         if(releaseLockTokenSlashedCalled){
 41 |     |             return address(SLASHED_TOKEN_RECIPIENT).balance == avaxSlash && qi.balanceOf(SLASHED_TOKEN_RECIPIENT) == tokenSlash;
 42 |     |         }
 43 |     |         return true;
 44 |     |     }
 45 |     | }

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/chiemara/Setup.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {BaseSetup} from "@chimera/BaseSetup.sol";
   5 |     | 
   6 |     | import {Ignite} from "../../src/Ignite.sol";
   7 |     | import {PriceFeed} from "../contracts/PriceFeed.sol";
   8 |     | import {StakedAvax} from "../contracts/StakedAvax.sol";
   9 |     | import {FaucetToken} from "../contracts/FaucetToken.sol";
  10 |     | 
  11 |     | import {vm} from "@chimera/Hevm.sol";
  12 |     | 
  13 |     | abstract contract Setup is BaseSetup {
  14 | *   |     address admin = address(0x23457643);
  15 |     |     address[] internal users;
  16 |     |     bytes public blsKey =
  17 | *   |         hex"8d609cdd38ffc9ad01c91d1ae4fccb8cd6c75a6ad33a401da42283b0c3b59bbaf5abc172335ea4d9c31baa936818f0ab";
  18 |     | 
  19 | *   |     bytes public blsSignature =
  20 | *   |         hex"8c12c805e7dfe4bfe38be44685ee852d931d73b3c0820a1343d731909120cee4895f9b60990520a90d06a031a42e0f8616d415b543408c24be0da90d5e7fa8242f4fd32dadf34c790996ca474dbdbcd763f82c53880db19fd3b30d13cee278b4";
  21 |     | 
  22 | *   |     bytes public blsPoP = abi.encodePacked(blsKey, blsSignature);
  23 |     |     Ignite ignite;
  24 |     |     FaucetToken qi;
  25 |     |     StakedAvax sAvax;
  26 |     |     PriceFeed qiPriceFeed;
  27 |     |     PriceFeed avaxPriceFeed;
  28 |     |     // ghost variable
  29 |     |     uint256 totalEthStaked;
  30 |     |     uint256 totalQIStaked;
  31 | *   |     uint public qiPriceMultiplier = 10_000;
  32 | *   |     address public constant FEE_RECIPIENT = 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa;
  33 | *   |     address public constant SLASHED_TOKEN_RECIPIENT = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;
  34 |     | 
  35 | *   |     uint public gostMinimumContractBalance;
  36 | *   |     uint256[] public durations;
  37 | *   |     uint public constant VALIDATION_DURATION_TWO_WEEKS = 86400 * 7 * 2;
  38 | *   |     uint public constant VALIDATION_DURATION_FOUR_WEEKS = 86400 * 7 * 4;
  39 | *   |     uint public constant VALIDATION_DURATION_EIGHT_WEEKS = 86400 * 7 * 8;
  40 | *   |     uint public constant VALIDATION_DURATION_TWELVE_WEEKS = 86400 * 7 * 12;
  41 | *   |     uint[] public amountArr = [
  42 | *   |         25 ether,
  43 | *   |         50 ether,
  44 | *   |         75 ether,
  45 | *   |         100 ether,
  46 | *   |         125 ether,
  47 | *   |         150 ether,
  48 | *   |         175 ether,
  49 | *   |         200 ether,
  50 | *   |         225 ether,
  51 | *   |         250 ether,
  52 | *   |         275 ether,
  53 | *   |         300 ether,
  54 | *   |         325 ether,
  55 | *   |         350 ether,
  56 | *   |         375 ether,
  57 | *   |         400 ether,
  58 | *   |         425 ether,
  59 | *   |         450 ether,
  60 | *   |         475 ether,
  61 | *   |         500 ether
  62 |     |     ];
  63 |     | 
  64 | *   |     string[] public nodeIds;
  65 | *   |     uint[] public failRegistrationIndices;
  66 | *   |     uint[] public successRegistrationIndices;
  67 | *   |     bool public releaseLockTokenFailedCalled;
  68 | *   |     bool public releaseLockTokenSuccessCalled;
  69 | *   |     bool public releaseLockTokenSlashedCalled;
  70 |     | 
  71 | *   |     uint public avaxFee;
  72 | *   |     uint public avaxSlash;
  73 | *   |     uint public tokenFee;
  74 |     |     uint public tokenSlash;
  75 | *   |     bool public isRegisteredCalled;
  76 |     |     function boundValue(
  77 |     |         uint256 value,
  78 |     |         uint256 min,
  79 |     |         uint256 max
  80 |     |     ) public pure returns (uint256) {
  81 | *   |         return min + (value % (max - min));
  82 |     |     }
  83 |     | 
  84 |     |     function setup() internal virtual override {
  85 |     |         users.push(address(0x1));
  86 |     |         users.push(address(0x2));
  87 |     |         users.push(address(0x3));
  88 | *   |         vm.prank(admin);
  89 | *   |         qiPriceFeed = new PriceFeed(1_000_000);
  90 | *   |         vm.prank(admin);
  91 | *   |         avaxPriceFeed = new PriceFeed(2_000_000_000);
  92 | *   |         vm.prank(admin);
  93 | *   |         sAvax = new StakedAvax();
  94 | *   |         vm.prank(admin);
  95 | *   |         qi = new FaucetToken("BENQI", "QI", 18);
  96 | *   |         vm.prank(admin);
  97 | *   |         ignite = new Ignite();
  98 | *   |         vm.prank(admin);
  99 | *   |         ignite.initialize(
 100 |     |             address(sAvax),
 101 |     |             address(qi),
 102 |     |             address(avaxPriceFeed),
 103 | *   |             1 days,
 104 |     |             address(qiPriceFeed),
 105 |     |             1 days,
 106 |     |             25 ether, // min eth
 107 | *   |             1500 ether // max eth
 108 |     |         );
 109 | *   |         for (uint i = 0; i < users.length; i++) {
 110 | *   |             vm.prank(users[i]);
 111 | *   |             qi.mint(10000000000000000 ether); // mint qi
 112 | *   |             vm.deal(users[i], 10000000000000000 ether); // mint eth
 113 | *   |             vm.prank(users[i]);
 114 | *   |             qi.approve(address(ignite), type(uint256).max);
 115 |     |         }
 116 | *   |         vm.prank(admin);
 117 | *   |         ignite.grantRole(keccak256("ROLE_WITHDRAW"), admin);
 118 | *   |         vm.prank(admin);
 119 | *   |         ignite.grantRole(keccak256("ROLE_RELEASE_LOCKED_TOKENS"), admin);
 120 |     | 
 121 | *   |         vm.prank(admin);
 122 | *   |         ignite.addPaymentToken(address(qi), address(qiPriceFeed), 1 days);
 123 | *   |         durations.push(VALIDATION_DURATION_TWO_WEEKS);
 124 |     |         durations.push(VALIDATION_DURATION_FOUR_WEEKS);
 125 |     |         durations.push(VALIDATION_DURATION_EIGHT_WEEKS);
 126 |     |         durations.push(VALIDATION_DURATION_TWELVE_WEEKS);
 127 |     |         // register_With_Erc20_Fee(0,45,0);
 128 |     |         // echidna_check_qi_balance();
 129 |     |         // revert();
 130 |     |     }
 131 |     | }
 132 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/chiemara/TargetFunctions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {BaseTargetFunctions} from "@chimera/BaseTargetFunctions.sol";
   5 |     | import {BeforeAfter} from "./BeforeAfter.sol";
   6 |     | import {Properties} from "./Properties.sol";
   7 |     | import {vm} from "@chimera/Hevm.sol";
   8 |     | import {IgniteStorage} from "../../src/IgniteStorage.sol";
   9 |     | event LogUint(uint);
  10 |     | 
  11 |     | abstract contract TargetFunctions is BaseTargetFunctions, Properties {
  12 |     |     function register_with_stake(
  13 |     |         uint256 userIndex,
  14 |     |         uint256 amountIndex,
  15 |     |         uint256 nodeId,
  16 |     |         uint validationDurationIndex
  17 |     |     ) public {
  18 | *   |         amountIndex = boundValue(amountIndex, 0, amountArr.length);
  19 |     |         userIndex = boundValue(userIndex, 0, users.length);
  20 |     |         validationDurationIndex = boundValue(
  21 |     |             validationDurationIndex,
  22 |     |             0,
  23 | *   |             durations.length
  24 |     |         ); // 2-12 weeks
  25 | *   |         uint validationDuration = durations[validationDurationIndex];
  26 |     |         // uint registrationFee = ignite.getRegistrationFee(validationDuration);
  27 |     | 
  28 |     |         // gostMinimumContractBalance += registrationFee;
  29 |     | 
  30 | *   |         address user = users[userIndex];
  31 | *   |         uint amount = amountArr[amountIndex];
  32 | *   |         (, int avaxPrice, , , ) = avaxPriceFeed.latestRoundData();
  33 | *   |         (, int qiPrice, , , ) = qiPriceFeed.latestRoundData();
  34 | *   |         uint qiAmount = (uint(avaxPrice) * (2000e18 - amount)) /
  35 |     |             uint(qiPrice) /
  36 | *   |             10;
  37 | *   |         totalQIStaked += qiAmount;
  38 | *   |         totalEthStaked += amount;
  39 | *   |         vm.prank(user);
  40 | *   |         ignite.registerWithStake{value: amount}(
  41 | *   |             string(abi.encodePacked("NodeID-", nodeId)),
  42 |     |             blsPoP,
  43 |     |             validationDuration
  44 |     |         );
  45 | *   |         nodeIds.push(string(abi.encodePacked("NodeID-", nodeId)));
  46 | *   |         isRegisteredCalled = true;
  47 |     |     }
  48 |     |     function register_with_erc20_fee(
  49 |     |         uint256 userIndex,
  50 |     |         uint256 nodeId,
  51 |     |         uint validationDurationIndex
  52 |     |     ) public {
  53 | *   |         userIndex = boundValue(userIndex, 0, users.length);
  54 |     |         validationDurationIndex = boundValue(
  55 |     |             validationDurationIndex,
  56 |     |             0,
  57 |     |             durations.length
  58 |     |         ); // 2-12 weeks
  59 | *   |         uint validationDuration = durations[validationDurationIndex];
  60 |     | 
  61 | *   |         address user = users[userIndex];
  62 | *   |         uint registrationFee = ignite.getRegistrationFee(validationDuration);
  63 |     | 
  64 | *   |         (, int avaxPrice, , , ) = avaxPriceFeed.latestRoundData();
  65 | *   |         (, int qiPrice, , , ) = qiPriceFeed.latestRoundData();
  66 | *   |         uint tokenAmount = (uint(avaxPrice) * registrationFee) /
  67 |     |             uint(qiPrice) /
  68 | *   |             10 ** (18 - qi.decimals());
  69 | *   |         uint amount = (tokenAmount * qiPriceMultiplier) / 10_000;
  70 | *   |         totalQIStaked += amount;
  71 | *   |         vm.prank(user);
  72 | *   |         ignite.registerWithErc20Fee(
  73 |     |             address(qi),
  74 | *   |             string(abi.encodePacked("NodeID-", nodeId)),
  75 |     |             blsPoP,
  76 |     |             validationDuration
  77 |     |         );
  78 |     |         nodeIds.push(string(abi.encodePacked("NodeID-", nodeId)));
  79 |     |         isRegisteredCalled = true;
  80 |     |     }
  81 |     | 
  82 |     |     function register_with_prevalidated_qiStake(
  83 |     |         uint256 userIndex,
  84 |     |         uint256 nodeId,
  85 |     |         uint validationDurationIndex
  86 |     |     ) public {
  87 | *   |         userIndex = boundValue(userIndex, 0, users.length);
  88 |     |         validationDurationIndex = boundValue(
  89 |     |             validationDurationIndex,
  90 |     |             0,
  91 | *   |             durations.length
  92 |     |         );
  93 | *   |         uint validationDuration = durations[validationDurationIndex];
  94 |     | 
  95 | *   |         address user = users[userIndex];
  96 |     | 
  97 | *   |         vm.prank(admin);
  98 | *   |         ignite.grantRole(
  99 | *   |             keccak256("ROLE_REGISTER_WITH_FLEXIBLE_PRICE_CHECK"),
 100 |     |             user
 101 |     |         );
 102 |     | 
 103 | *   |         (, int avaxPrice, , , ) = avaxPriceFeed.latestRoundData();
 104 | *   |         (, int qiPrice, , , ) = qiPriceFeed.latestRoundData();
 105 |     |         // 200 AVAX + 1 AVAX fee = 201e18
 106 | *   |         uint expectedQiAmount = (uint(avaxPrice) * 201e18) / uint(qiPrice);
 107 |     | 
 108 | *   |         uint qiAmount = (expectedQiAmount * 9) / 10;
 109 |     | 
 110 | *   |         totalQIStaked += qiAmount;
 111 | *   |         vm.prank(user);
 112 | *   |         ignite.registerWithPrevalidatedQiStake(
 113 |     |             address(user),
 114 | *   |             string(abi.encodePacked("NodeID-", nodeId)),
 115 |     |             blsPoP,
 116 |     |             validationDuration,
 117 |     |             qiAmount
 118 |     |         );
 119 |     |         nodeIds.push(string(abi.encodePacked("NodeID-", nodeId)));
 120 |     |         isRegisteredCalled = true;
 121 |     |     }
 122 |     |     function register_without_collateral(
 123 |     |         uint256 userIndex,
 124 |     |         uint256 nodeId,
 125 |     |         uint validationDurationIndex
 126 |     |     ) public {
 127 | *   |         userIndex = boundValue(userIndex, 0, users.length);
 128 |     |         validationDurationIndex = boundValue(
 129 |     |             validationDurationIndex,
 130 |     |             0,
 131 | *   |             durations.length+1
 132 |     |         );
 133 | *   |         uint256[5] memory _durations = [durations[0],durations[1],durations[2],durations[3],86400 * 365];
 134 |     |         uint validationDuration = _durations[validationDurationIndex];
 135 |     | 
 136 | *   |         address user = users[userIndex];
 137 |     | 
 138 | *   |         vm.prank(admin);
 139 | *   |         ignite.grantRole(keccak256("ROLE_REGISTER_WITHOUT_COLLATERAL"), user);
 140 |     | 
 141 | *   |         vm.prank(user);
 142 | *   |         ignite.registerWithoutCollateral(
 143 | *   |             string(abi.encodePacked("NodeID-", nodeId)),
 144 |     |             blsPoP,
 145 |     |             validationDuration
 146 |     |         );
 147 | *   |         nodeIds.push(string(abi.encodePacked("NodeID-", nodeId)));
 148 |     |     }
 149 |     | 
 150 |     |     function register_with_avax_fee(
 151 |     |         uint256 userIndex,
 152 |     |         uint validationDurationIndex,
 153 |     |         uint256 nodeId
 154 |     |     ) public {
 155 | *   |         userIndex = boundValue(userIndex, 0, users.length);
 156 |     |         validationDurationIndex = boundValue(
 157 |     |             validationDurationIndex,
 158 |     |             0,
 159 | *   |             durations.length
 160 |     |         );
 161 | *   |         uint validationDuration = durations[validationDurationIndex];
 162 |     | 
 163 | *   |         address user = users[userIndex];
 164 | *   |         uint amount = ignite.getRegistrationFee(validationDuration);
 165 | *   |         gostMinimumContractBalance += amount;
 166 | *   |         totalEthStaked += amount;
 167 |     | 
 168 | *   |         vm.prank(user);
 169 | *   |         ignite.registerWithAvaxFee{value: amount}(
 170 | *   |             string(abi.encodePacked("NodeID-", nodeId)),
 171 |     |             blsPoP,
 172 |     |             validationDuration
 173 |     |         );
 174 |     |         nodeIds.push(string(abi.encodePacked("NodeID-", nodeId)));
 175 |     |         isRegisteredCalled = true;
 176 |     |     }
 177 |     | 
 178 |     |     function withdraw_eth(uint amount) public {
 179 | *   |         uint minBal = ignite.minimumContractBalance();
 180 |     |         amount = boundValue(
 181 |     |             amount,
 182 |     |             minBal + 1,
 183 | *   |             address(ignite).balance - minBal + 1
 184 |     |         );
 185 |     | 
 186 | *   |         totalEthStaked -= amount;
 187 | *   |         vm.prank(admin);
 188 | *   |         ignite.withdraw(amount);
 189 |     |     }
 190 |     |     function release_locked_tokens_failed(uint256 nodeIdIndex) public {
 191 | *   |         nodeIdIndex = boundValue(nodeIdIndex, 0, nodeIds.length);
 192 | *   |         string memory nodeId = nodeIds[nodeIdIndex];
 193 | *   |         uint registrationIndex = ignite.registrationIndicesByNodeId(nodeId);
 194 |     |         (
 195 |     |             ,
 196 |     |             ,
 197 |     |             ,
 198 |     |             bool feePaid,
 199 |     |             IgniteStorage.TokenDepositDetails memory tokenDeposits,
 200 |     |             ,
 201 |     |             ,
 202 |     |             ,
 203 |     |             ,
 204 |     |             bool withdrawable
 205 | *   |         ) = ignite.registrations(registrationIndex);
 206 |     | 
 207 | *   |         if (!withdrawable) {
 208 | *   |             if (feePaid) {
 209 | *   |                 vm.prank(admin);
 210 | *   |                 ignite.releaseLockedTokens{value: 0}(
 211 |     |                     nodeId,
 212 |     |                     true // bool failed
 213 |     |                 );
 214 |     |             } else {
 215 | *   |                 if (tokenDeposits.avaxAmount > 0) {
 216 | *   |                     failRegistrationIndices.push(registrationIndex);
 217 |     |                 }
 218 | *   |                 totalEthStaked += tokenDeposits.avaxAmount;
 219 | *   |                 gostMinimumContractBalance += tokenDeposits.avaxAmount;
 220 |     | 
 221 | *   |                 vm.prank(admin);
 222 | *   |                 ignite.releaseLockedTokens{value: tokenDeposits.avaxAmount}(
 223 |     |                     nodeId,
 224 |     |                     true // bool failed
 225 |     |                 );
 226 |     |             }
 227 |     |         }
 228 | *   |         releaseLockTokenFailedCalled = true;
 229 |     |     }
 230 |     | 
 231 | *   |     function release_locked_tokens_success(uint256 nodeIdIndex) public {
 232 | *   |         if(!isRegisteredCalled) return;
 233 | *   |         nodeIdIndex = boundValue(nodeIdIndex, 0, nodeIds.length);
 234 | *   |         string memory nodeId = nodeIds[nodeIdIndex];
 235 | *   |         uint registrationIndex = ignite.registrationIndicesByNodeId(nodeId);
 236 |     |         (
 237 |     |             ,
 238 |     |             ,
 239 |     |             ,
 240 |     |             bool feePaid,
 241 |     |             IgniteStorage.TokenDepositDetails memory tokenDeposits,
 242 |     |             ,
 243 |     |             ,
 244 |     |             ,
 245 |     |             ,
 246 |     |             bool withdrawable
 247 | *   |         ) = ignite.registrations(registrationIndex);
 248 |     | 
 249 | *   |         if(!withdrawable){
 250 | *   |         if (feePaid) {
 251 | *   |             if (tokenDeposits.avaxAmount > 0) {
 252 | *   |                 successRegistrationIndices.push(registrationIndex);
 253 | *   |                 totalEthStaked -= tokenDeposits.avaxAmount;
 254 | *   |                 vm.prank(admin);
 255 | *   |                 ignite.releaseLockedTokens{value: 0}(
 256 |     |                     nodeId,
 257 |     |                     false // bool failed
 258 |     |                 );
 259 | *   |                 avaxFee += tokenDeposits.avaxAmount;
 260 | *   |                 gostMinimumContractBalance -= tokenDeposits.avaxAmount;
 261 |     | 
 262 |     |             } else {
 263 |     | 
 264 |     | 
 265 | *   |                 successRegistrationIndices.push(registrationIndex);
 266 | *   |                 totalQIStaked -= tokenDeposits.tokenAmount;
 267 | *   |                 vm.prank(admin);
 268 | *   |                 ignite.releaseLockedTokens{value: 0}(
 269 |     |                     nodeId,
 270 |     |                     false // bool failed
 271 |     |                 );
 272 | *   |                 tokenFee += tokenDeposits.tokenAmount;
 273 |     |             }
 274 |     |         }else{
 275 | *   |             if (ignite.qiRewardEligibilityByNodeId(nodeId)) {
 276 |     | 
 277 | *   |             uint fee = tokenDeposits.tokenAmount / 201;
 278 |     | 
 279 | *   |                 totalQIStaked -= fee;
 280 |     | 
 281 | *   |                 tokenFee += fee;
 282 |     | 
 283 | *   |                   vm.prank(admin);
 284 | *   |                 ignite.releaseLockedTokens{value: 0}(
 285 |     |                     nodeId,
 286 |     |                     false // bool failed
 287 |     |                 );
 288 |     |             }else {
 289 | *   |                 uint msgValue = tokenDeposits.avaxAmount+10;
 290 | *   |                 totalEthStaked += msgValue;
 291 | *   |             gostMinimumContractBalance += msgValue;
 292 | *   |                 vm.prank(admin);
 293 | *   |                 ignite.releaseLockedTokens{value: msgValue}(
 294 |     |                     nodeId,
 295 |     |                     false // bool failed
 296 |     |                 );
 297 |     |             }
 298 |     |         }
 299 |     |         }
 300 | *   |         releaseLockTokenSuccessCalled = true;
 301 |     |     }
 302 |     | 
 303 |     | 
 304 |     | 
 305 |     |      function release_locked_tokens_slash(uint256 nodeIdIndex) public {
 306 | *   |         nodeIdIndex = boundValue(nodeIdIndex, 0, nodeIds.length);
 307 | *   |         string memory nodeId = nodeIds[nodeIdIndex];
 308 | *   |         uint registrationIndex = ignite.registrationIndicesByNodeId(nodeId);
 309 |     |         (
 310 |     |             ,
 311 |     |             ,
 312 |     |             ,
 313 |     |             bool feePaid,
 314 |     |             IgniteStorage.TokenDepositDetails memory tokenDeposits,
 315 |     |             ,
 316 |     |             uint qiSlashPercentage,
 317 |     |             uint avaxSlashPercentage,
 318 |     |             ,
 319 |     |             bool withdrawable
 320 | *   |         ) = ignite.registrations(registrationIndex);
 321 |     | 
 322 |     |                 uint msgValue = tokenDeposits.avaxAmount;
 323 | *   |         if(!withdrawable){
 324 | *   |         if (!feePaid && msgValue != 0) {
 325 |     | 
 326 |     |        
 327 |     | 
 328 | *   |                 vm.prank(admin);
 329 | *   |                 ignite.releaseLockedTokens{value: msgValue}(
 330 |     |                     nodeId,
 331 |     |                     false // bool failed
 332 |     |                 );
 333 |     | 
 334 |     | 
 335 | *   |             if (qiSlashPercentage > 0) {
 336 | *   |                 uint qiSlashAmount = tokenDeposits.tokenAmount * qiSlashPercentage / 10_000;
 337 |     | 
 338 | *   |                 totalQIStaked -= qiSlashAmount;
 339 |     |             }
 340 |     | 
 341 | *   |             if (avaxSlashPercentage > 0) {
 342 |     |                 uint avaxSlashAmount = tokenDeposits.avaxAmount * avaxSlashPercentage / 10_000;
 343 |     | 
 344 |     |                 gostMinimumContractBalance += msgValue - avaxSlashAmount;
 345 |     | 
 346 |     |                 totalEthStaked -= avaxSlashAmount;
 347 |     |             } else {
 348 | *   |                 gostMinimumContractBalance += msgValue;
 349 |     |             }
 350 |     | 
 351 |     | 
 352 |     |         }
 353 |     |         }
 354 | *   |         releaseLockTokenSlashedCalled = true;
 355 |     |     }
 356 |     | }
 357 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/contracts/FaucetToken.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | 
  7 |     | 
  8 | *   | contract FaucetToken is ERC20 {
  9 |     |     uint8 private _decimals;
 10 |     | 
 11 |     |     constructor(
 12 |     |         string memory _symbol,
 13 |     |         string memory _name,
 14 |     |         uint8 __decimals
 15 | *   |     ) ERC20(string(abi.encodePacked(_symbol, _name)), _symbol) {
 16 | *   |         _decimals = __decimals;
 17 |     |     }
 18 |     | 
 19 |     |     function mint(uint256 _amount) external {
 20 | *   |         _mint(msg.sender, _amount);
 21 |     |     }
 22 |     | 
 23 |     |     function decimals() public view override returns (uint8) {
 24 | *   |         return _decimals;
 25 |     |     }
 26 |     | }
 27 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/contracts/PriceFeed.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | 
  6 |     | /**
  7 |     |  * @dev A mock price feed that provides latestRoundData with the Chainlink
  8 |     |  *      price feed interface. A setPrice function (which does not enforce
  9 |     |  *      access control) is used to set the price after the initial value
 10 |     |  *      specified during deployment.
 11 |     |  */
 12 | *   | contract PriceFeed {
 13 |     |     int256 price;
 14 |     |     uint256 updatedAt;
 15 |     | 
 16 |     |     constructor(int256 _price) {
 17 |     |         price = _price;
 18 | *   |         updatedAt = block.timestamp;
 19 |     |     }
 20 |     | 
 21 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {
 22 | *   |         return (0, price, 0, updatedAt, 0);
 23 |     |     }
 24 |     | 
 25 |     |     function setPrice(int256 _price) external {
 26 |     |         price = _price;
 27 |     |     }
 28 |     | 
 29 |     |     function setUpdatedAtTimestamp(uint256 _updatedAt) external {
 30 |     |         updatedAt = _updatedAt;
 31 |     |     }
 32 |     | }
 33 |     | 

/Users/asad97/my-stuff/audits/ignit-cyfrin/ignite/test/contracts/StakedAvax.sol
 1 |     | // SPDX-License-Identifier: UNLICENSED
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | 
 5 | *   | contract StakedAvax {
 6 |     |     function accrueRewards(uint amount) external {}
 7 |     | }
 8 |     | 

